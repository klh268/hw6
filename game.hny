from synch import *


def Game() returns game:
    game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
            .active_game: Condition(), .players: Condition()}

def game_umpire(g):
    acquire(?g->lock)
    while True:
        
        # If there's an active game, wait for it to finish
        while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
            wait(?g->active_game, ?g->lock)
       
       #let gives me an error here on the next line
        let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
            for i in range((pairedplayers // 2)):
                g->team1 = add(g->team1, g->waiting[i])
                g->team2 = add(g->team2, g->waiting[i + 1])

            # Create a new waiting list excluding the players who have been paired
            #harmony gives me errors 
            for i in range(pairedplayers):
                del g->waiting[0]

        # Signal players to start the game
        # assert (len(g->waiting) <= 1)
        notifyAll(?g->players)
    release(?g->lock)


def game_join(g, id) returns teams:
    acquire(?g->lock)
    # Add player to waiting list
    g->waiting = g->waiting + [id,]

    # If teams are empty (game complete), signal umpire to make new teams
    if (len(g->team1) == 0) and (len(g->team2) == 0):
        notify(?g->active_game)
    
    # Wait for the game to start, don't enter unless one team has no players, team sizes uneven,
    # or player is not on either team yet
    while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
        wait(?g->players, ?g->lock)

    # Return tuple of teams
    teams = (g->team1, g->team2)

    release(?g->lock)

def game_leave(g, id):
    acquire(?g->lock)
    
    # Remove player from team
    if id in g->team1:
        g->team1 = remove(g->team1, id)
    elif id in g->team2:
        g->team2 = remove(g->team2, id)
    
    # If teams are empty (game complete), signal umpire to make new teams
    if (len(g->team1) == 0) and (len(g->team2) == 0):
        notify(?g->active_game)

    release(?g->lock)