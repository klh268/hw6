Issue: Non-terminating state

Modules:
  bag: /Users/katherineheatzig/Library/Python/3.12/lib/python/site-packages/harmony_model_checker/modules/bag.hny
  game: game_broken.hny
  set: /Users/katherineheatzig/Library/Python/3.12/lib/python/site-packages/harmony_model_checker/modules/set.hny
  __main__: teamsDummy.hny
  synch: /Users/katherineheatzig/Library/Python/3.12/lib/python/site-packages/harmony_model_checker/modules/synch.hny
  list: /Users/katherineheatzig/Library/Python/3.12/lib/python/site-packages/harmony_model_checker/modules/list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=15 column=26
  source code:       from game import * 
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 54
  explanation:       jump over method definition: set program counter to 54
  module:            list
  start statement:   line=2 column=1
  end statement:     line=2 column=35
  source code:       def subseq(s, b, e) returns result:
                     ^^^

Step 3:
  program counter:   54
  hvm code:          Push PC(57)
  explanation:       push constant PC(57)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(57)]

Step 4:
  program counter:   55
  hvm code:          Builtin(list$tail)
  explanation:       pop pc () and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   56
  hvm code:          Jump 602
  explanation:       jump over method definition: set program counter to 602
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 6:
  program counter:   602
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(605)]

Step 7:
  program counter:   603
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc () and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   604
  hvm code:          Jump 624
  explanation:       jump over method definition: set program counter to 624
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 9:
  program counter:   624
  hvm code:          Push PC(627)
  explanation:       push constant PC(627)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(627)]

Step 10:
  program counter:   625
  hvm code:          Builtin(bag$size)
  explanation:       pop pc () and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   626
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 12:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(649)]

Step 13:
  program counter:   647
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc () and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   648
  hvm code:          Jump 665
  explanation:       jump over method definition: set program counter to 665
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 15:
  program counter:   665
  hvm code:          Push PC(668)
  explanation:       push constant PC(668)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(668)]

Step 16:
  program counter:   666
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc () and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   667
  hvm code:          Jump 693
  explanation:       jump over method definition: set program counter to 693
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 18:
  program counter:   693
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(696)]

Step 19:
  program counter:   694
  hvm code:          Builtin(bag$add)
  explanation:       pop pc () and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   695
  hvm code:          Jump 722
  explanation:       jump over method definition: set program counter to 722
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 21:
  program counter:   722
  hvm code:          Push PC(725)
  explanation:       push constant PC(725)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(725)]

Step 22:
  program counter:   723
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc () and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   724
  hvm code:          Jump 1967
  explanation:       jump over method definition: set program counter to 1967
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 24:
  program counter:   1967
  hvm code:          Push ()
  explanation:       push constant ()
  module:            __main__
  start statement:   line=4 column=1
  end statement:     line=4 column=16
  source code:       thegame = Game()
                                   ^^
  stack:             [{:}, []]

Step 25:
  program counter:   1968
  hvm code:          Apply PC(1587)
  explanation:       pop an argument ([]) and call method (1587: "Game")
  source code:       thegame = Game()
                               ^^^^^^
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 31490, []]

Step 26:
  program counter:   1587
  hvm code:          Frame Game()
  explanation:       pop argument () and run method "Game"
  module:            game
  start statement:   line=4 column=1
  end statement:     line=4 column=24
  source code:       def Game() returns game:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}]

Step 27:
  program counter:   1588
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, {:}]

Step 28:
  program counter:   1589
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, {:}, "waiting"]

Step 29:
  program counter:   1590
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, {:}, "waiting", []]

Step 30:
  program counter:   1591
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([], "waiting", {:}); add key/value pair to dictionary; push result ({ "waiting": [] })
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "waiting": [] }]

Step 31:
  program counter:   1592
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "waiting": [] }, "team1"]

Step 32:
  program counter:   1593
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "waiting": [] }, "team1", {}]

Step 33:
  program counter:   1594
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({}, "team1", { "waiting": [] }); add key/value pair to dictionary; push result ({ "team1": {}, "waiting": [] })
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "waiting": [] }]

Step 34:
  program counter:   1595
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "waiting": [] }, "team2"]

Step 35:
  program counter:   1596
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "waiting": [] }, "team2", {}]

Step 36:
  program counter:   1597
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({}, "team2", { "team1": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "team1": {}, "team2": {}, "waiting": [] })
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }]

Step 37:
  program counter:   1598
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock"]

Step 38:
  program counter:   1599
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", []]

Step 39:
  program counter:   1600
  hvm code:          Apply PC(931)
  explanation:       pop an argument ([]) and call method (931: "Lock")
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  call trace:        __init__() --> Game() --> Lock()
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, []]

Step 40:
  program counter:   931
  hvm code:          Frame Lock()
  explanation:       pop argument () and run method "Lock"
  module:            synch
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}]

Step 41:
  program counter:   932
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                                      ^^^^^

Step 42:
  program counter:   933
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=26 column=22
  end expression:    line=26 column=26
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, False]

Step 43:
  program counter:   934
  hvm code:          Apply PC(912)
  explanation:       pop an argument (False) and call method (912: "BinSema")
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Game() --> Lock() --> BinSema(False)
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, False]

Step 44:
  program counter:   912
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (False), assign to initial, and run method "BinSema"
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: False }
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}]

Step 45:
  program counter:   913
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 46:
  program counter:   914
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 47:
  program counter:   915
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False]

Step 48:
  program counter:   916
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False, {}]

Step 49:
  program counter:   917
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False, {}, False]

Step 50:
  program counter:   918
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False, { False }]

Step 51:
  program counter:   919
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False, { False }, True]

Step 52:
  program counter:   920
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False, { False, True }]

Step 53:
  program counter:   921
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, False); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, True]

Step 54:
  program counter:   922
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}]

Step 55:
  program counter:   923
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 56:
  program counter:   924
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 57:
  program counter:   925
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}, False]

Step 58:
  program counter:   926
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 59:
  program counter:   927
  hvm code:          StoreVar sema
  explanation:       pop value (False) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: False }
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, [], 14946, {:}]

Step 60:
  program counter:   928
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game() --> Lock()
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}, False]

Step 61:
  program counter:   935
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable \"result\"
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 25602, {:}]

Step 62:
  program counter:   936
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 31490, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", False]

Step 63:
  program counter:   1601
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "lock", { "team1": {}, "team2": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "lock": False, "team1": {}, "team2": {}, "waiting": [] })
  module:            game
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }]

Step 64:
  program counter:   1602
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game"]

Step 65:
  program counter:   1603
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", []]

Step 66:
  program counter:   1604
  hvm code:          Apply PC(989)
  explanation:       pop an argument ([]) and call method (989: "Condition")
  source code:       .active_game: Condition(), .players: Condition()}
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, []]

Step 67:
  program counter:   989
  hvm code:          Frame Condition()
  explanation:       pop argument () and run method "Condition"
  module:            synch
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}]

Step 68:
  program counter:   990
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^

Step 69:
  program counter:   991
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  start expression:  line=44 column=14
  end expression:    line=44 column=22
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, PC(541)]

Step 70:
  program counter:   992
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, PC(541), []]

Step 71:
  program counter:   993
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, ?PC(541)[[]]]

Step 72:
  program counter:   994
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=44 column=14
  end expression:    line=44 column=24
  call trace:        __init__() --> Game() --> Condition() --> empty()
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, [], 15906, []]

Step 73:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, [], 15906, {:}]

Step 74:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, [], 15906, {:}, {:}]

Step 75:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, [], 15906, {:}]

Step 76:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}, {:}]

Step 77:
  program counter:   995
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable \"result\"
  module:            synch
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 25666, {:}]

Step 78:
  program counter:   996
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 31490, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", {:}]

Step 79:
  program counter:   1605
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "active_game", { "lock": False, "team1": {}, "team2": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] })
  module:            game
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }]

Step 80:
  program counter:   1606
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players"]

Step 81:
  program counter:   1607
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", []]

Step 82:
  program counter:   1608
  hvm code:          Apply PC(989)
  explanation:       pop an argument ([]) and call method (989: "Condition")
  source code:       .active_game: Condition(), .players: Condition()}
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, []]

Step 83:
  program counter:   989
  hvm code:          Frame Condition()
  explanation:       pop argument () and run method "Condition"
  module:            synch
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}]

Step 84:
  program counter:   990
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^

Step 85:
  program counter:   991
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  start expression:  line=44 column=14
  end expression:    line=44 column=22
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, PC(541)]

Step 86:
  program counter:   992
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, PC(541), []]

Step 87:
  program counter:   993
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, ?PC(541)[[]]]

Step 88:
  program counter:   994
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=44 column=14
  end expression:    line=44 column=24
  call trace:        __init__() --> Game() --> Condition() --> empty()
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, [], 15906, []]

Step 89:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, [], 15906, {:}]

Step 90:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, [], 15906, {:}, {:}]

Step 91:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, [], 15906, {:}]

Step 92:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}, {:}]

Step 93:
  program counter:   995
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable \"result\"
  module:            synch
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 25730, {:}]

Step 94:
  program counter:   996
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", {:}]

Step 95:
  program counter:   1609
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "players", { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] })
  module:            game
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 31490, {:}, { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }]

Step 96:
  program counter:   1610
  hvm code:          StoreVar game
  explanation:       pop value ({ "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }) and store locally in variable \"game\"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  method variables:  { game: { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] } }
  stack:             [{:}, [], 31490, {:}]

Step 97:
  program counter:   1611
  hvm code:          ReturnOp(game)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=4 column=1
  end statement:     line=4 column=24
  source code:       def Game() returns game:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__()
  stack:             [{:}, { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }]

Step 98:
  program counter:   1969
  hvm code:          Store thegame
  explanation:       pop value ({ "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }) and store into variable thegame
  module:            __main__
  start statement:   line=4 column=1
  end statement:     line=4 column=16
  source code:       thegame = Game()
                     ^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] } }
  stack:             [{:}]

Step 99:
  program counter:   1970
  hvm code:          Jump 2000
  explanation:       jump over method definition: set program counter to 2000
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^

Step 100:
  program counter:   2000
  hvm code:          Push ?PC(1614)
  explanation:       push constant ?PC(1614)
  start statement:   line=12 column=1
  end statement:     line=12 column=35
  source code:       spawn eternal game_umpire(?thegame)
                                   ^^^^^^^^^^^
  stack:             [{:}, ?PC(1614)]

Step 101:
  program counter:   2001
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       spawn eternal game_umpire(?thegame)
                                                ^^^^^^^
  stack:             [{:}, ?PC(1614), ?thegame]

Step 102:
  program counter:   2002
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (?thegame, ?PC(1614)); push result (?PC(1614)[?thegame])
  source code:       spawn eternal game_umpire(?thegame)
                                   ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1614)[?thegame]]

Step 103:
  program counter:   2003
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn eternal game_umpire(?thegame)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1614)[?thegame], {:}]

Step 104:
  program counter:   2004
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (?thegame), and pc (1614: "game_umpire"), and spawn thread
  start expression:  line=12 column=1
  end expression:    line=12 column=35
  stack:             [{:}]

Step 105:
  program counter:   2005
  hvm code:          Push 1
  explanation:       push constant 1
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                 ^
  stack:             [{:}, 1]

Step 106:
  program counter:   2006
  hvm code:          Push 6
  explanation:       push constant 6
  source code:       for id in { 1 .. NPLAYERS}:
                                      ^^^^^^^^
  stack:             [{:}, 1, 6]

Step 107:
  program counter:   2007
  hvm code:          2-ary ..
  explanation:       pop 2 values (6, 1); range of integers; push result ({ 1, 2, 3, 4, 5, 6 })
  source code:       for id in { 1 .. NPLAYERS}:
                                 ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }]

Step 108:
  program counter:   2008
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 0]

Step 109:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (0) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (1) to id; push new index (1) and True
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  method variables:  { id: 1 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, True]

Step 110:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (True), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1]

Step 111:
  program counter:   2011
  hvm code:          Push ?PC(1971)
  explanation:       push constant ?PC(1971)
  start statement:   line=15 column=5
  end statement:     line=15 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1971)]

Step 112:
  program counter:   2012
  hvm code:          LoadVar id
  explanation:       push value (1) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1971), 1]

Step 113:
  program counter:   2013
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=15 column=18
  end expression:    line=15 column=19
  method variables:  { }

Step 114:
  program counter:   2014
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1971)); push result (?PC(1971)[1])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1971)[1]]

Step 115:
  program counter:   2015
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1971)[1], {:}]

Step 116:
  program counter:   2016
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1971: "player"), and spawn thread
  start expression:  line=15 column=5
  end expression:    line=15 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1]

Step 117:
  program counter:   2017
  hvm code:          Jump 2009
  explanation:       set program counter to 2009
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                              ^

Step 118:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (1) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (2) to id; push new index (2) and True
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  method variables:  { id: 2 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, True]

Step 119:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (True), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2]

Step 120:
  program counter:   2011
  hvm code:          Push ?PC(1971)
  explanation:       push constant ?PC(1971)
  start statement:   line=15 column=5
  end statement:     line=15 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1971)]

Step 121:
  program counter:   2012
  hvm code:          LoadVar id
  explanation:       push value (2) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1971), 2]

Step 122:
  program counter:   2013
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=15 column=18
  end expression:    line=15 column=19
  method variables:  { }

Step 123:
  program counter:   2014
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (2, ?PC(1971)); push result (?PC(1971)[2])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1971)[2]]

Step 124:
  program counter:   2015
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1971)[2], {:}]

Step 125:
  program counter:   2016
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (2), and pc (1971: "player"), and spawn thread
  start expression:  line=15 column=5
  end expression:    line=15 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2]

Step 126:
  program counter:   2017
  hvm code:          Jump 2009
  explanation:       set program counter to 2009
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                              ^

Step 127:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (2) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (3) to id; push new index (3) and True
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  method variables:  { id: 3 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, True]

Step 128:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (True), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3]

Step 129:
  program counter:   2011
  hvm code:          Push ?PC(1971)
  explanation:       push constant ?PC(1971)
  start statement:   line=15 column=5
  end statement:     line=15 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1971)]

Step 130:
  program counter:   2012
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1971), 3]

Step 131:
  program counter:   2013
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=15 column=18
  end expression:    line=15 column=19
  method variables:  { }

Step 132:
  program counter:   2014
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (3, ?PC(1971)); push result (?PC(1971)[3])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1971)[3]]

Step 133:
  program counter:   2015
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1971)[3], {:}]

Step 134:
  program counter:   2016
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (3), and pc (1971: "player"), and spawn thread
  start expression:  line=15 column=5
  end expression:    line=15 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3]

Step 135:
  program counter:   2017
  hvm code:          Jump 2009
  explanation:       set program counter to 2009
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                              ^

Step 136:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (3) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (4) to id; push new index (4) and True
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  method variables:  { id: 4 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, True]

Step 137:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (True), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4]

Step 138:
  program counter:   2011
  hvm code:          Push ?PC(1971)
  explanation:       push constant ?PC(1971)
  start statement:   line=15 column=5
  end statement:     line=15 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1971)]

Step 139:
  program counter:   2012
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1971), 4]

Step 140:
  program counter:   2013
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=15 column=18
  end expression:    line=15 column=19
  method variables:  { }

Step 141:
  program counter:   2014
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (4, ?PC(1971)); push result (?PC(1971)[4])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1971)[4]]

Step 142:
  program counter:   2015
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1971)[4], {:}]

Step 143:
  program counter:   2016
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (4), and pc (1971: "player"), and spawn thread
  start expression:  line=15 column=5
  end expression:    line=15 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4]

Step 144:
  program counter:   2017
  hvm code:          Jump 2009
  explanation:       set program counter to 2009
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                              ^

Step 145:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (4) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (5) to id; push new index (5) and True
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  method variables:  { id: 5 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, True]

Step 146:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (True), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5]

Step 147:
  program counter:   2011
  hvm code:          Push ?PC(1971)
  explanation:       push constant ?PC(1971)
  start statement:   line=15 column=5
  end statement:     line=15 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1971)]

Step 148:
  program counter:   2012
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1971), 5]

Step 149:
  program counter:   2013
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=15 column=18
  end expression:    line=15 column=19
  method variables:  { }

Step 150:
  program counter:   2014
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (5, ?PC(1971)); push result (?PC(1971)[5])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1971)[5]]

Step 151:
  program counter:   2015
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1971)[5], {:}]

Step 152:
  program counter:   2016
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (5), and pc (1971: "player"), and spawn thread
  start expression:  line=15 column=5
  end expression:    line=15 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5]

Step 153:
  program counter:   2017
  hvm code:          Jump 2009
  explanation:       set program counter to 2009
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                              ^

Step 154:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (5) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (6) to id; push new index (6) and True
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  method variables:  { id: 6 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, True]

Step 155:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (True), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6]

Step 156:
  program counter:   2011
  hvm code:          Push ?PC(1971)
  explanation:       push constant ?PC(1971)
  start statement:   line=15 column=5
  end statement:     line=15 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1971)]

Step 157:
  program counter:   2012
  hvm code:          LoadVar id
  explanation:       push value (6) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1971), 6]

Step 158:
  program counter:   2013
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=15 column=18
  end expression:    line=15 column=19
  method variables:  { }

Step 159:
  program counter:   2014
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (6, ?PC(1971)); push result (?PC(1971)[6])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1971)[6]]

Step 160:
  program counter:   2015
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1971)[6], {:}]

Step 161:
  program counter:   2016
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (6), and pc (1971: "player"), and spawn thread
  start expression:  line=15 column=5
  end expression:    line=15 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6]

Step 162:
  program counter:   2017
  hvm code:          Jump 2009
  explanation:       set program counter to 2009
  start statement:   line=14 column=1
  end statement:     line=14 column=26
  source code:       for id in { 1 .. NPLAYERS}:
                                              ^

Step 163:
  program counter:   2009
  hvm code:          Cut(id)
  explanation:       pop index (6) and value ({ 1, 2, 3, 4, 5, 6 }); out of range -> push False
  source code:       for id in { 1 .. NPLAYERS}:
                     ^^^
  stack:             [{:}, False]

Step 164:
  program counter:   2010
  hvm code:          JumpCond False 2018
  explanation:       pop value (False), compare to False, and jump to 2018 if the same
  start expression:  line=14 column=1
  end expression:    line=14 column=3
  stack:             [{:}]

Step 165:
  program counter:   2018
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=1 column=1
  end statement:     line=15 column=26
  source code:       from game import * 

Step 166:
  program counter:   2019
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start expression:  line=1 column=1
  end expression:    line=15 column=26
  new mode:          terminated
  stack:             [None]

================================================
Running thread T7: player(6)
mode:  runnable
stack: ['6']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1614 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T2: pc=1971 runnable player(1)
    about to run method player with argument 1
  T3: pc=1971 runnable player(2)
    about to run method player with argument 2
  T4: pc=1971 runnable player(3)
    about to run method player with argument 3
  T5: pc=1971 runnable player(4)
    about to run method player with argument 4
  T6: pc=1971 runnable player(5)
    about to run method player with argument 5
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }
state id: 7
================================================

Step 167:
  program counter:   1971
  hvm code:          Frame player(self)
  explanation:       pop argument (6), assign to self, and run method "player"
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 6 }
  call trace:        player(6)
  stack:             [{:}]

Step 168:
  program counter:   1972
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 169:
  program counter:   1973
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 170:
  program counter:   1974
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 171:
  program counter:   1975
  hvm code:          LoadVar self
  explanation:       push value (6) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 6]

Step 172:
  program counter:   1976
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (6, [?thegame]); insert first value into the second; push result ([?thegame, 6])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 6 ]]

Step 173:
  program counter:   1977
  hvm code:          Apply PC(1759)
  explanation:       pop an argument ([?thegame, 6]) and call method (1759: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, [ ?thegame, 6 ]]

Step 174:
  program counter:   1759
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 6]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 6 }
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 175:
  program counter:   1760
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 176:
  program counter:   1761
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "lock"]

Step 177:
  program counter:   1762
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["lock"]]

Step 178:
  program counter:   1763
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, ?thegame["lock"]]

Step 179:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }]

Step 180:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(6) --> game_join(?thegame, 6) --> acquire(?thegame["lock"])

Step 181:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 182:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 183:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }, False]

Step 184:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }, True]

Step 185:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }]

Step 186:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 187:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 188:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 189:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 190:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }, ?thegame["lock"], True]

Step 191:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": {:}, "team1": {}, "team2": {}, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28210, { "g": ?thegame, "id": 6 }]

Step 192:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 193:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 6 }
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, None]

Step 194:
  program counter:   1764
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 195:
  program counter:   1765
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=38 column=5
  end statement:     line=38 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 196:
  program counter:   1766
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "waiting"]

Step 197:
  program counter:   1767
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"]]

Step 198:
  program counter:   1768
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], ?thegame]

Step 199:
  program counter:   1769
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 200:
  program counter:   1770
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 201:
  program counter:   1771
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([])
  start expression:  line=38 column=18
  end expression:    line=38 column=27
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], []]

Step 202:
  program counter:   1772
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], [], []]

Step 203:
  program counter:   1773
  hvm code:          LoadVar id
  explanation:       push value (6) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], [], [], 6]

Step 204:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (6, []); insert first value into the second; push result ([6])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], [], [ 6 ]]

Step 205:
  program counter:   1775
  hvm code:          2-ary +
  explanation:       pop 2 values ([6], []); concatenate the lists; push result ([6])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["waiting"], [ 6 ]]

Step 206:
  program counter:   1776
  hvm code:          Store
  explanation:       pop value ([6]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": {:}, "team1": {}, "team2": {}, "waiting": [ 6 ] } }
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 207:
  program counter:   1777
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=41 column=5
  end statement:     line=41 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 208:
  program counter:   1778
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "team1"]

Step 209:
  program counter:   1779
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["team1"]]

Step 210:
  program counter:   1780
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=41 column=13
  end expression:    line=41 column=20
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, {}]

Step 211:
  program counter:   1781
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0]

Step 212:
  program counter:   1782
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, 0]

Step 213:
  program counter:   1783
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, True]

Step 214:
  program counter:   1784
  hvm code:          JumpCond False 1793
  explanation:       pop value (True), compare to False, and jump to 1793 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 215:
  program counter:   1785
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 216:
  program counter:   1786
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "team2"]

Step 217:
  program counter:   1787
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["team2"]]

Step 218:
  program counter:   1788
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=41 column=38
  end expression:    line=41 column=45
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, {}]

Step 219:
  program counter:   1789
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0]

Step 220:
  program counter:   1790
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, 0]

Step 221:
  program counter:   1791
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, True]

Step 222:
  program counter:   1792
  hvm code:          Jump 1794
  explanation:       set program counter to 1794
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 223:
  program counter:   1794
  hvm code:          JumpCond False 1800
  explanation:       pop value (True), compare to False, and jump to 1800 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 224:
  program counter:   1795
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 225:
  program counter:   1796
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "active_game"]

Step 226:
  program counter:   1797
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["active_game"]]

Step 227:
  program counter:   1798
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, ?thegame["active_game"]]

Step 228:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }]

Step 229:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(6) --> game_join(?thegame, 6) --> notify(?thegame["active_game"])

Step 230:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, ?thegame["active_game"]]

Step 231:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}]

Step 232:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, PC(541)]

Step 233:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, PC(541), []]

Step 234:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, ?PC(541)[[]]]

Step 235:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(6) --> game_join(?thegame, 6) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, [], 17186, []]

Step 236:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 237:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 238:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 239:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(6) --> game_join(?thegame, 6) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, {:}, {:}]

Step 240:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }, False]

Step 241:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 28770, { "g": ?thegame, "id": 6 }]

Step 242:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 243:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 244:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 6 }
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, None]

Step 245:
  program counter:   1799
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 246:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 247:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "team1"]

Step 248:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["team1"]]

Step 249:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, {}]

Step 250:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0]

Step 251:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, ?thegame]

Step 252:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, ?thegame, "team2"]

Step 253:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, ?thegame["team2"]]

Step 254:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, 0, {}]

Step 255:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, 0]

Step 256:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, False]

Step 257:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 258:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 259:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "team1"]

Step 260:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["team1"]]

Step 261:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, {}]

Step 262:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 0]

Step 263:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 6 }, 0, 0]

Step 264:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, True]

Step 265:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 266:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 6 }, True]

Step 267:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 268:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, []]

Step 269:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], ?thegame]

Step 270:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], ?thegame, "players"]

Step 271:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], ?thegame["players"]]

Step 272:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ ?thegame["players"] ]]

Step 273:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 6 }, [ ?thegame["players"] ], ?thegame]

Step 274:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 275:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 276:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 277:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 278:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 279:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, 0]

Step 280:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 281:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 282:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, []]

Step 283:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 284:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 285:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 286:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])

Step 287:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605)]

Step 288:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), []]

Step 289:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [], ?thegame["players"]]

Step 290:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [], {:}]

Step 291:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [ {:} ]]

Step 292:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 293:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 294:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 295:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]))
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, [], 16242, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 296:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, 0]

Step 297:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 298:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"]]

Step 299:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696)]

Step 300:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696), []]

Step 301:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 302:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696), [], {:}]

Step 303:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696), [ {:} ]]

Step 304:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 305:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], PC(696), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 306:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])], PC(696)); push result (?PC(696)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], ?PC(696)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 307:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"]) --> add({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]))
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], [], 16418, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 308:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 309:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6 ] } }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 310:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 311:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["lock"], False]

Step 312:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6 ] } }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 313:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T4: player(3)
mode:  runnable
stack: ['3']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1614 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T2: pc=1971 runnable player(1)
    about to run method player with argument 1
  T3: pc=1971 runnable player(2)
    about to run method player with argument 2
  T5: pc=1971 runnable player(4)
    about to run method player with argument 4
  T6: pc=1971 runnable player(5)
    about to run method player with argument 5
  T7: pc=1032 blocked player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6 ] }
state id: 3712
================================================

Step 314:
  program counter:   1971
  hvm code:          Frame player(self)
  explanation:       pop argument (3), assign to self, and run method "player"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 3 }
  call trace:        player(3)
  stack:             [{:}]

Step 315:
  program counter:   1972
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 316:
  program counter:   1973
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 317:
  program counter:   1974
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 318:
  program counter:   1975
  hvm code:          LoadVar self
  explanation:       push value (3) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 3]

Step 319:
  program counter:   1976
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (3, [?thegame]); insert first value into the second; push result ([?thegame, 3])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 3 ]]

Step 320:
  program counter:   1977
  hvm code:          Apply PC(1759)
  explanation:       pop an argument ([?thegame, 3]) and call method (1759: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, [ ?thegame, 3 ]]

Step 321:
  program counter:   1759
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 3]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 3 }
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 322:
  program counter:   1760
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 323:
  program counter:   1761
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "lock"]

Step 324:
  program counter:   1762
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["lock"]]

Step 325:
  program counter:   1763
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, ?thegame["lock"]]

Step 326:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }]

Step 327:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(3) --> game_join(?thegame, 3) --> acquire(?thegame["lock"])

Step 328:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 329:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 330:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }, False]

Step 331:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }, True]

Step 332:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }]

Step 333:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 334:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 335:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 336:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 337:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }, ?thegame["lock"], True]

Step 338:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6 ] } }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28210, { "g": ?thegame, "id": 3 }]

Step 339:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 340:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 3 }
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, None]

Step 341:
  program counter:   1764
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 342:
  program counter:   1765
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=38 column=5
  end statement:     line=38 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 343:
  program counter:   1766
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "waiting"]

Step 344:
  program counter:   1767
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"]]

Step 345:
  program counter:   1768
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], ?thegame]

Step 346:
  program counter:   1769
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 347:
  program counter:   1770
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 348:
  program counter:   1771
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6])
  start expression:  line=38 column=18
  end expression:    line=38 column=27
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], [ 6 ]]

Step 349:
  program counter:   1772
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], [ 6 ], []]

Step 350:
  program counter:   1773
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], [ 6 ], [], 3]

Step 351:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (3, []); insert first value into the second; push result ([3])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], [ 6 ], [ 3 ]]

Step 352:
  program counter:   1775
  hvm code:          2-ary +
  explanation:       pop 2 values ([3], [6]); concatenate the lists; push result ([6, 3])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["waiting"], [ 6, 3 ]]

Step 353:
  program counter:   1776
  hvm code:          Store
  explanation:       pop value ([6, 3]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3 ] } }
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 354:
  program counter:   1777
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=41 column=5
  end statement:     line=41 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 355:
  program counter:   1778
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "team1"]

Step 356:
  program counter:   1779
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["team1"]]

Step 357:
  program counter:   1780
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=41 column=13
  end expression:    line=41 column=20
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, {}]

Step 358:
  program counter:   1781
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0]

Step 359:
  program counter:   1782
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, 0]

Step 360:
  program counter:   1783
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, True]

Step 361:
  program counter:   1784
  hvm code:          JumpCond False 1793
  explanation:       pop value (True), compare to False, and jump to 1793 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 362:
  program counter:   1785
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 363:
  program counter:   1786
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "team2"]

Step 364:
  program counter:   1787
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["team2"]]

Step 365:
  program counter:   1788
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=41 column=38
  end expression:    line=41 column=45
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, {}]

Step 366:
  program counter:   1789
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0]

Step 367:
  program counter:   1790
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, 0]

Step 368:
  program counter:   1791
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, True]

Step 369:
  program counter:   1792
  hvm code:          Jump 1794
  explanation:       set program counter to 1794
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 370:
  program counter:   1794
  hvm code:          JumpCond False 1800
  explanation:       pop value (True), compare to False, and jump to 1800 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 371:
  program counter:   1795
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 372:
  program counter:   1796
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "active_game"]

Step 373:
  program counter:   1797
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["active_game"]]

Step 374:
  program counter:   1798
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, ?thegame["active_game"]]

Step 375:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }]

Step 376:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(3) --> game_join(?thegame, 3) --> notify(?thegame["active_game"])

Step 377:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, ?thegame["active_game"]]

Step 378:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}]

Step 379:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, PC(541)]

Step 380:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, PC(541), []]

Step 381:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, ?PC(541)[[]]]

Step 382:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(3) --> game_join(?thegame, 3) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, [], 17186, []]

Step 383:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 384:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 385:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 386:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(3) --> game_join(?thegame, 3) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, {:}, {:}]

Step 387:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }, False]

Step 388:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 28770, { "g": ?thegame, "id": 3 }]

Step 389:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 390:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 391:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 3 }
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, None]

Step 392:
  program counter:   1799
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 393:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 394:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "team1"]

Step 395:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["team1"]]

Step 396:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, {}]

Step 397:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0]

Step 398:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, ?thegame]

Step 399:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, ?thegame, "team2"]

Step 400:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, ?thegame["team2"]]

Step 401:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, 0, {}]

Step 402:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, 0]

Step 403:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, False]

Step 404:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 405:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 406:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "team1"]

Step 407:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["team1"]]

Step 408:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, {}]

Step 409:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 0]

Step 410:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 3 }, 0, 0]

Step 411:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, True]

Step 412:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 413:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 3 }, True]

Step 414:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 415:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, []]

Step 416:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], ?thegame]

Step 417:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], ?thegame, "players"]

Step 418:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], ?thegame["players"]]

Step 419:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ ?thegame["players"] ]]

Step 420:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 3 }, [ ?thegame["players"] ], ?thegame]

Step 421:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 422:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 423:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 424:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 425:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 426:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, 0]

Step 427:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 428:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 429:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, []]

Step 430:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 431:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 432:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 433:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])

Step 434:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605)]

Step 435:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), []]

Step 436:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [], ?thegame["players"]]

Step 437:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 })
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 438:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 439:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 440:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 441:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 442:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]))
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, [], 16242, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 443:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, 0]

Step 444:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 445:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"]]

Step 446:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696)]

Step 447:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696), []]

Step 448:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 449:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 })
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 450:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 451:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 452:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 453:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])], PC(696)); push result (?PC(696)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], ?PC(696)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 454:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"]) --> add({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]))
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], [], 16418, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 455:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 456:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3 ] } }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 457:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 458:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["lock"], False]

Step 459:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3 ] } }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 460:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T6: player(5)
mode:  runnable
stack: ['5']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1614 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T2: pc=1971 runnable player(1)
    about to run method player with argument 1
  T3: pc=1971 runnable player(2)
    about to run method player with argument 2
  T4: pc=1032 blocked player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=1971 runnable player(4)
    about to run method player with argument 4
  T7: pc=1032 blocked player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3 ] }
state id: 17490
================================================

Step 461:
  program counter:   1971
  hvm code:          Frame player(self)
  explanation:       pop argument (5), assign to self, and run method "player"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 5 }
  call trace:        player(5)
  stack:             [{:}]

Step 462:
  program counter:   1972
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 463:
  program counter:   1973
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 464:
  program counter:   1974
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 465:
  program counter:   1975
  hvm code:          LoadVar self
  explanation:       push value (5) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 5]

Step 466:
  program counter:   1976
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (5, [?thegame]); insert first value into the second; push result ([?thegame, 5])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 5 ]]

Step 467:
  program counter:   1977
  hvm code:          Apply PC(1759)
  explanation:       pop an argument ([?thegame, 5]) and call method (1759: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, [ ?thegame, 5 ]]

Step 468:
  program counter:   1759
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 5]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 469:
  program counter:   1760
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 470:
  program counter:   1761
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "lock"]

Step 471:
  program counter:   1762
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["lock"]]

Step 472:
  program counter:   1763
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, ?thegame["lock"]]

Step 473:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }]

Step 474:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(5) --> game_join(?thegame, 5) --> acquire(?thegame["lock"])

Step 475:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 476:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 477:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }, False]

Step 478:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }, True]

Step 479:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }]

Step 480:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 481:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 482:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 483:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 484:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }, ?thegame["lock"], True]

Step 485:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3 ] } }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28210, { "g": ?thegame, "id": 5 }]

Step 486:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 487:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, None]

Step 488:
  program counter:   1764
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 489:
  program counter:   1765
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=38 column=5
  end statement:     line=38 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 490:
  program counter:   1766
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "waiting"]

Step 491:
  program counter:   1767
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"]]

Step 492:
  program counter:   1768
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], ?thegame]

Step 493:
  program counter:   1769
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 494:
  program counter:   1770
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 495:
  program counter:   1771
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3])
  start expression:  line=38 column=18
  end expression:    line=38 column=27
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], [ 6, 3 ]]

Step 496:
  program counter:   1772
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], [ 6, 3 ], []]

Step 497:
  program counter:   1773
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], [ 6, 3 ], [], 5]

Step 498:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (5, []); insert first value into the second; push result ([5])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], [ 6, 3 ], [ 5 ]]

Step 499:
  program counter:   1775
  hvm code:          2-ary +
  explanation:       pop 2 values ([5], [6, 3]); concatenate the lists; push result ([6, 3, 5])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["waiting"], [ 6, 3, 5 ]]

Step 500:
  program counter:   1776
  hvm code:          Store
  explanation:       pop value ([6, 3, 5]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5 ] } }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 501:
  program counter:   1777
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=41 column=5
  end statement:     line=41 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 502:
  program counter:   1778
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "team1"]

Step 503:
  program counter:   1779
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["team1"]]

Step 504:
  program counter:   1780
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=41 column=13
  end expression:    line=41 column=20
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, {}]

Step 505:
  program counter:   1781
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0]

Step 506:
  program counter:   1782
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, 0]

Step 507:
  program counter:   1783
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, True]

Step 508:
  program counter:   1784
  hvm code:          JumpCond False 1793
  explanation:       pop value (True), compare to False, and jump to 1793 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 509:
  program counter:   1785
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 510:
  program counter:   1786
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "team2"]

Step 511:
  program counter:   1787
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["team2"]]

Step 512:
  program counter:   1788
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=41 column=38
  end expression:    line=41 column=45
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, {}]

Step 513:
  program counter:   1789
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0]

Step 514:
  program counter:   1790
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, 0]

Step 515:
  program counter:   1791
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, True]

Step 516:
  program counter:   1792
  hvm code:          Jump 1794
  explanation:       set program counter to 1794
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 517:
  program counter:   1794
  hvm code:          JumpCond False 1800
  explanation:       pop value (True), compare to False, and jump to 1800 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 518:
  program counter:   1795
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 519:
  program counter:   1796
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "active_game"]

Step 520:
  program counter:   1797
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["active_game"]]

Step 521:
  program counter:   1798
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, ?thegame["active_game"]]

Step 522:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }]

Step 523:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"])

Step 524:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, ?thegame["active_game"]]

Step 525:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}]

Step 526:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, PC(541)]

Step 527:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, PC(541), []]

Step 528:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, ?PC(541)[[]]]

Step 529:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, [], 17186, []]

Step 530:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 531:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 532:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 533:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, {:}, {:}]

Step 534:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }, False]

Step 535:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 28770, { "g": ?thegame, "id": 5 }]

Step 536:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 537:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 538:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, None]

Step 539:
  program counter:   1799
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 540:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 541:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "team1"]

Step 542:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["team1"]]

Step 543:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, {}]

Step 544:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0]

Step 545:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, ?thegame]

Step 546:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, ?thegame, "team2"]

Step 547:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, ?thegame["team2"]]

Step 548:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, 0, {}]

Step 549:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, 0]

Step 550:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, False]

Step 551:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 552:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 553:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "team1"]

Step 554:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["team1"]]

Step 555:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, {}]

Step 556:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 0]

Step 557:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 5 }, 0, 0]

Step 558:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, True]

Step 559:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 560:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 5 }, True]

Step 561:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 562:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, []]

Step 563:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], ?thegame]

Step 564:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], ?thegame, "players"]

Step 565:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], ?thegame["players"]]

Step 566:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ ?thegame["players"] ]]

Step 567:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 5 }, [ ?thegame["players"] ], ?thegame]

Step 568:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 569:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 570:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 571:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 572:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 573:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, 0]

Step 574:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 575:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 576:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, []]

Step 577:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 578:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 579:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 580:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])

Step 581:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605)]

Step 582:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), []]

Step 583:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [], ?thegame["players"]]

Step 584:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 })
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 585:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 586:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 587:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 588:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 589:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]))
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, [], 16242, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 590:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, 0]

Step 591:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 592:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"]]

Step 593:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696)]

Step 594:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), []]

Step 595:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 596:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 })
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 597:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 598:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 599:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 600:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])], PC(696)); push result (?PC(696)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], ?PC(696)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 601:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"]) --> add({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]))
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], [], 16418, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 602:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 603:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5 ] } }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 604:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 605:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["lock"], False]

Step 606:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5 ] } }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 607:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T5: player(4)
mode:  runnable
stack: ['4']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1614 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T2: pc=1971 runnable player(1)
    about to run method player with argument 1
  T3: pc=1971 runnable player(2)
    about to run method player with argument 2
  T4: pc=1032 blocked player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T6: pc=1032 blocked player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1032 blocked player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5 ] }
state id: 48374
================================================

Step 608:
  program counter:   1971
  hvm code:          Frame player(self)
  explanation:       pop argument (4), assign to self, and run method "player"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 4 }
  call trace:        player(4)
  stack:             [{:}]

Step 609:
  program counter:   1972
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 610:
  program counter:   1973
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 611:
  program counter:   1974
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 612:
  program counter:   1975
  hvm code:          LoadVar self
  explanation:       push value (4) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 4]

Step 613:
  program counter:   1976
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (4, [?thegame]); insert first value into the second; push result ([?thegame, 4])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 4 ]]

Step 614:
  program counter:   1977
  hvm code:          Apply PC(1759)
  explanation:       pop an argument ([?thegame, 4]) and call method (1759: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, [ ?thegame, 4 ]]

Step 615:
  program counter:   1759
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 4]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 616:
  program counter:   1760
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 617:
  program counter:   1761
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "lock"]

Step 618:
  program counter:   1762
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["lock"]]

Step 619:
  program counter:   1763
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, ?thegame["lock"]]

Step 620:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }]

Step 621:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(4) --> game_join(?thegame, 4) --> acquire(?thegame["lock"])

Step 622:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 623:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 624:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }, False]

Step 625:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }, True]

Step 626:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }]

Step 627:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 628:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 629:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 630:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 631:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }, ?thegame["lock"], True]

Step 632:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5 ] } }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28210, { "g": ?thegame, "id": 4 }]

Step 633:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 634:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, None]

Step 635:
  program counter:   1764
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 636:
  program counter:   1765
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=38 column=5
  end statement:     line=38 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 637:
  program counter:   1766
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "waiting"]

Step 638:
  program counter:   1767
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"]]

Step 639:
  program counter:   1768
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], ?thegame]

Step 640:
  program counter:   1769
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 641:
  program counter:   1770
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 642:
  program counter:   1771
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3, 5])
  start expression:  line=38 column=18
  end expression:    line=38 column=27
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], [ 6, 3, 5 ]]

Step 643:
  program counter:   1772
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], [ 6, 3, 5 ], []]

Step 644:
  program counter:   1773
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], [ 6, 3, 5 ], [], 4]

Step 645:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (4, []); insert first value into the second; push result ([4])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], [ 6, 3, 5 ], [ 4 ]]

Step 646:
  program counter:   1775
  hvm code:          2-ary +
  explanation:       pop 2 values ([4], [6, 3, 5]); concatenate the lists; push result ([6, 3, 5, 4])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["waiting"], [ 6, 3, 5, 4 ]]

Step 647:
  program counter:   1776
  hvm code:          Store
  explanation:       pop value ([6, 3, 5, 4]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4 ] } }
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 648:
  program counter:   1777
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=41 column=5
  end statement:     line=41 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 649:
  program counter:   1778
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "team1"]

Step 650:
  program counter:   1779
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["team1"]]

Step 651:
  program counter:   1780
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=41 column=13
  end expression:    line=41 column=20
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, {}]

Step 652:
  program counter:   1781
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0]

Step 653:
  program counter:   1782
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, 0]

Step 654:
  program counter:   1783
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, True]

Step 655:
  program counter:   1784
  hvm code:          JumpCond False 1793
  explanation:       pop value (True), compare to False, and jump to 1793 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 656:
  program counter:   1785
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 657:
  program counter:   1786
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "team2"]

Step 658:
  program counter:   1787
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["team2"]]

Step 659:
  program counter:   1788
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=41 column=38
  end expression:    line=41 column=45
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, {}]

Step 660:
  program counter:   1789
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0]

Step 661:
  program counter:   1790
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, 0]

Step 662:
  program counter:   1791
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, True]

Step 663:
  program counter:   1792
  hvm code:          Jump 1794
  explanation:       set program counter to 1794
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 664:
  program counter:   1794
  hvm code:          JumpCond False 1800
  explanation:       pop value (True), compare to False, and jump to 1800 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 665:
  program counter:   1795
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 666:
  program counter:   1796
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "active_game"]

Step 667:
  program counter:   1797
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["active_game"]]

Step 668:
  program counter:   1798
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, ?thegame["active_game"]]

Step 669:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }]

Step 670:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(4) --> game_join(?thegame, 4) --> notify(?thegame["active_game"])

Step 671:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, ?thegame["active_game"]]

Step 672:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}]

Step 673:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, PC(541)]

Step 674:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, PC(541), []]

Step 675:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, ?PC(541)[[]]]

Step 676:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(4) --> game_join(?thegame, 4) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, [], 17186, []]

Step 677:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 678:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 679:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 680:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(4) --> game_join(?thegame, 4) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, {:}, {:}]

Step 681:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }, False]

Step 682:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 28770, { "g": ?thegame, "id": 4 }]

Step 683:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 684:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 685:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, None]

Step 686:
  program counter:   1799
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 687:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 688:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "team1"]

Step 689:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["team1"]]

Step 690:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, {}]

Step 691:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0]

Step 692:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, ?thegame]

Step 693:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, ?thegame, "team2"]

Step 694:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, ?thegame["team2"]]

Step 695:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, 0, {}]

Step 696:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, 0]

Step 697:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, False]

Step 698:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 699:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 700:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "team1"]

Step 701:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["team1"]]

Step 702:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, {}]

Step 703:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 0]

Step 704:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 4 }, 0, 0]

Step 705:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, True]

Step 706:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 707:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 4 }, True]

Step 708:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 709:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, []]

Step 710:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], ?thegame]

Step 711:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], ?thegame, "players"]

Step 712:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], ?thegame["players"]]

Step 713:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ ?thegame["players"] ]]

Step 714:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 4 }, [ ?thegame["players"] ], ?thegame]

Step 715:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 716:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 717:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 718:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 719:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 720:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, 0]

Step 721:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 722:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 723:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, []]

Step 724:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 725:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 726:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 727:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])

Step 728:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605)]

Step 729:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), []]

Step 730:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [], ?thegame["players"]]

Step 731:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 })
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 732:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 733:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 734:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 735:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 736:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]))
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, [], 16242, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 737:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, 0]

Step 738:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 739:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"]]

Step 740:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696)]

Step 741:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696), []]

Step 742:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 743:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 })
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 744:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 745:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 746:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 747:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])], PC(696)); push result (?PC(696)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], ?PC(696)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 748:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"]) --> add({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]))
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], [], 16418, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 749:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 750:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4 ] } }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 751:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 752:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["lock"], False]

Step 753:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4 ] } }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 754:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T2: player(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1614 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T3: pc=1971 runnable player(2)
    about to run method player with argument 2
  T4: pc=1032 blocked player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=1032 blocked player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T6: pc=1032 blocked player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1032 blocked player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4 ] }
state id: 103842
================================================

Step 755:
  program counter:   1971
  hvm code:          Frame player(self)
  explanation:       pop argument (1), assign to self, and run method "player"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        player(1)
  stack:             [{:}]

Step 756:
  program counter:   1972
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 757:
  program counter:   1973
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 758:
  program counter:   1974
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 759:
  program counter:   1975
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 1]

Step 760:
  program counter:   1976
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?thegame]); insert first value into the second; push result ([?thegame, 1])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 1 ]]

Step 761:
  program counter:   1977
  hvm code:          Apply PC(1759)
  explanation:       pop an argument ([?thegame, 1]) and call method (1759: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, [ ?thegame, 1 ]]

Step 762:
  program counter:   1759
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 1]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 763:
  program counter:   1760
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 764:
  program counter:   1761
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "lock"]

Step 765:
  program counter:   1762
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["lock"]]

Step 766:
  program counter:   1763
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, ?thegame["lock"]]

Step 767:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }]

Step 768:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(1) --> game_join(?thegame, 1) --> acquire(?thegame["lock"])

Step 769:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 770:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 771:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }, False]

Step 772:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }, True]

Step 773:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }]

Step 774:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 775:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 776:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 777:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 778:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }, ?thegame["lock"], True]

Step 779:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4 ] } }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28210, { "g": ?thegame, "id": 1 }]

Step 780:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 781:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, None]

Step 782:
  program counter:   1764
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 783:
  program counter:   1765
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=38 column=5
  end statement:     line=38 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 784:
  program counter:   1766
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "waiting"]

Step 785:
  program counter:   1767
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"]]

Step 786:
  program counter:   1768
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], ?thegame]

Step 787:
  program counter:   1769
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 788:
  program counter:   1770
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 789:
  program counter:   1771
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3, 5, 4])
  start expression:  line=38 column=18
  end expression:    line=38 column=27
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], [ 6, 3, 5, 4 ]]

Step 790:
  program counter:   1772
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], [ 6, 3, 5, 4 ], []]

Step 791:
  program counter:   1773
  hvm code:          LoadVar id
  explanation:       push value (1) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], [ 6, 3, 5, 4 ], [], 1]

Step 792:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], [ 6, 3, 5, 4 ], [ 1 ]]

Step 793:
  program counter:   1775
  hvm code:          2-ary +
  explanation:       pop 2 values ([1], [6, 3, 5, 4]); concatenate the lists; push result ([6, 3, 5, 4, 1])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["waiting"], [ 6, 3, 5, 4, 1 ]]

Step 794:
  program counter:   1776
  hvm code:          Store
  explanation:       pop value ([6, 3, 5, 4, 1]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1 ] } }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 795:
  program counter:   1777
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=41 column=5
  end statement:     line=41 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 796:
  program counter:   1778
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "team1"]

Step 797:
  program counter:   1779
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["team1"]]

Step 798:
  program counter:   1780
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=41 column=13
  end expression:    line=41 column=20
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, {}]

Step 799:
  program counter:   1781
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0]

Step 800:
  program counter:   1782
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, 0]

Step 801:
  program counter:   1783
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, True]

Step 802:
  program counter:   1784
  hvm code:          JumpCond False 1793
  explanation:       pop value (True), compare to False, and jump to 1793 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 803:
  program counter:   1785
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 804:
  program counter:   1786
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "team2"]

Step 805:
  program counter:   1787
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["team2"]]

Step 806:
  program counter:   1788
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=41 column=38
  end expression:    line=41 column=45
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, {}]

Step 807:
  program counter:   1789
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0]

Step 808:
  program counter:   1790
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, 0]

Step 809:
  program counter:   1791
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, True]

Step 810:
  program counter:   1792
  hvm code:          Jump 1794
  explanation:       set program counter to 1794
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 811:
  program counter:   1794
  hvm code:          JumpCond False 1800
  explanation:       pop value (True), compare to False, and jump to 1800 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 812:
  program counter:   1795
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 813:
  program counter:   1796
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "active_game"]

Step 814:
  program counter:   1797
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["active_game"]]

Step 815:
  program counter:   1798
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, ?thegame["active_game"]]

Step 816:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }]

Step 817:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"])

Step 818:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, ?thegame["active_game"]]

Step 819:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}]

Step 820:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, PC(541)]

Step 821:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, PC(541), []]

Step 822:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, ?PC(541)[[]]]

Step 823:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, [], 17186, []]

Step 824:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 825:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 826:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 827:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, {:}, {:}]

Step 828:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }, False]

Step 829:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 28770, { "g": ?thegame, "id": 1 }]

Step 830:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 831:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 832:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, None]

Step 833:
  program counter:   1799
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 834:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 835:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "team1"]

Step 836:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["team1"]]

Step 837:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, {}]

Step 838:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0]

Step 839:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, ?thegame]

Step 840:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, ?thegame, "team2"]

Step 841:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, ?thegame["team2"]]

Step 842:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, 0, {}]

Step 843:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, 0]

Step 844:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, False]

Step 845:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 846:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 847:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "team1"]

Step 848:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["team1"]]

Step 849:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, {}]

Step 850:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 0]

Step 851:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 1 }, 0, 0]

Step 852:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, True]

Step 853:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 854:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 1 }, True]

Step 855:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 856:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, []]

Step 857:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], ?thegame]

Step 858:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], ?thegame, "players"]

Step 859:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], ?thegame["players"]]

Step 860:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ]]

Step 861:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ], ?thegame]

Step 862:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 863:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 864:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 865:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 866:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 867:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, 0]

Step 868:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 869:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 870:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, []]

Step 871:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 872:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 873:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 874:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])

Step 875:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605)]

Step 876:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), []]

Step 877:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [], ?thegame["players"]]

Step 878:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 })
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 879:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 880:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 881:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 882:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 883:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, [], 16242, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 884:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, 0]

Step 885:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 886:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"]]

Step 887:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696)]

Step 888:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), []]

Step 889:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 890:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 })
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 891:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 892:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 893:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 894:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])], PC(696)); push result (?PC(696)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], ?PC(696)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 895:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> add({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], [], 16418, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 896:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 897:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1 ] } }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 898:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 899:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"], False]

Step 900:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1 ] } }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 901:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T3: player(2)
mode:  runnable
stack: ['2']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1614 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=1032 blocked player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=1032 blocked player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T6: pc=1032 blocked player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1032 blocked player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1 ] }
state id: 216816
================================================

Step 902:
  program counter:   1971
  hvm code:          Frame player(self)
  explanation:       pop argument (2), assign to self, and run method "player"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 2 }
  call trace:        player(2)
  stack:             [{:}]

Step 903:
  program counter:   1972
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 904:
  program counter:   1973
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 905:
  program counter:   1974
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 906:
  program counter:   1975
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 2]

Step 907:
  program counter:   1976
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [?thegame]); insert first value into the second; push result ([?thegame, 2])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 2 ]]

Step 908:
  program counter:   1977
  hvm code:          Apply PC(1759)
  explanation:       pop an argument ([?thegame, 2]) and call method (1759: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, [ ?thegame, 2 ]]

Step 909:
  program counter:   1759
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 2]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 2 }
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 910:
  program counter:   1760
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 911:
  program counter:   1761
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "lock"]

Step 912:
  program counter:   1762
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["lock"]]

Step 913:
  program counter:   1763
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, ?thegame["lock"]]

Step 914:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }]

Step 915:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(2) --> game_join(?thegame, 2) --> acquire(?thegame["lock"])

Step 916:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 917:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 918:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }, False]

Step 919:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }, True]

Step 920:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }]

Step 921:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 922:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 923:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 924:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 925:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }, ?thegame["lock"], True]

Step 926:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1 ] } }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28210, { "g": ?thegame, "id": 2 }]

Step 927:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 928:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 2 }
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, None]

Step 929:
  program counter:   1764
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=36 column=5
  end statement:     line=36 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 930:
  program counter:   1765
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=38 column=5
  end statement:     line=38 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 931:
  program counter:   1766
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "waiting"]

Step 932:
  program counter:   1767
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"]]

Step 933:
  program counter:   1768
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], ?thegame]

Step 934:
  program counter:   1769
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 935:
  program counter:   1770
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 936:
  program counter:   1771
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3, 5, 4, 1])
  start expression:  line=38 column=18
  end expression:    line=38 column=27
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], [ 6, 3, 5, 4, 1 ]]

Step 937:
  program counter:   1772
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], [ 6, 3, 5, 4, 1 ], []]

Step 938:
  program counter:   1773
  hvm code:          LoadVar id
  explanation:       push value (2) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], [ 6, 3, 5, 4, 1 ], [], 2]

Step 939:
  program counter:   1774
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], [ 6, 3, 5, 4, 1 ], [ 2 ]]

Step 940:
  program counter:   1775
  hvm code:          2-ary +
  explanation:       pop 2 values ([2], [6, 3, 5, 4, 1]); concatenate the lists; push result ([6, 3, 5, 4, 1, 2])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["waiting"], [ 6, 3, 5, 4, 1, 2 ]]

Step 941:
  program counter:   1776
  hvm code:          Store
  explanation:       pop value ([6, 3, 5, 4, 1, 2]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 942:
  program counter:   1777
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=41 column=5
  end statement:     line=41 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 943:
  program counter:   1778
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "team1"]

Step 944:
  program counter:   1779
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["team1"]]

Step 945:
  program counter:   1780
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=41 column=13
  end expression:    line=41 column=20
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, {}]

Step 946:
  program counter:   1781
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0]

Step 947:
  program counter:   1782
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, 0]

Step 948:
  program counter:   1783
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, True]

Step 949:
  program counter:   1784
  hvm code:          JumpCond False 1793
  explanation:       pop value (True), compare to False, and jump to 1793 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 950:
  program counter:   1785
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 951:
  program counter:   1786
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "team2"]

Step 952:
  program counter:   1787
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["team2"]]

Step 953:
  program counter:   1788
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=41 column=38
  end expression:    line=41 column=45
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, {}]

Step 954:
  program counter:   1789
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0]

Step 955:
  program counter:   1790
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, 0]

Step 956:
  program counter:   1791
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, True]

Step 957:
  program counter:   1792
  hvm code:          Jump 1794
  explanation:       set program counter to 1794
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 958:
  program counter:   1794
  hvm code:          JumpCond False 1800
  explanation:       pop value (True), compare to False, and jump to 1800 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 959:
  program counter:   1795
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 960:
  program counter:   1796
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "active_game"]

Step 961:
  program counter:   1797
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["active_game"]]

Step 962:
  program counter:   1798
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, ?thegame["active_game"]]

Step 963:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }]

Step 964:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(2) --> game_join(?thegame, 2) --> notify(?thegame["active_game"])

Step 965:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, ?thegame["active_game"]]

Step 966:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}]

Step 967:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, PC(541)]

Step 968:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, PC(541), []]

Step 969:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, ?PC(541)[[]]]

Step 970:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(2) --> game_join(?thegame, 2) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, [], 17186, []]

Step 971:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 972:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 973:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 974:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(2) --> game_join(?thegame, 2) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, {:}, {:}]

Step 975:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }, False]

Step 976:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 28770, { "g": ?thegame, "id": 2 }]

Step 977:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 978:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 979:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 2 }
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, None]

Step 980:
  program counter:   1799
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=42 column=9
  end statement:     line=42 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 981:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 982:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "team1"]

Step 983:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["team1"]]

Step 984:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, {}]

Step 985:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0]

Step 986:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, ?thegame]

Step 987:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, ?thegame, "team2"]

Step 988:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, ?thegame["team2"]]

Step 989:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, 0, {}]

Step 990:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, 0]

Step 991:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, False]

Step 992:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 993:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 994:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "team1"]

Step 995:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["team1"]]

Step 996:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, {}]

Step 997:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 0]

Step 998:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 2 }, 0, 0]

Step 999:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, True]

Step 1000:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 1001:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 2 }, True]

Step 1002:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 1003:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, []]

Step 1004:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], ?thegame]

Step 1005:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], ?thegame, "players"]

Step 1006:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], ?thegame["players"]]

Step 1007:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ ?thegame["players"] ]]

Step 1008:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 2 }, [ ?thegame["players"] ], ?thegame]

Step 1009:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 1010:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 1011:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 1012:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 1013:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 1014:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, 0]

Step 1015:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 1016:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 1017:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, []]

Step 1018:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1019:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 1020:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 1021:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])

Step 1022:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605)]

Step 1023:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), []]

Step 1024:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [], ?thegame["players"]]

Step 1025:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 })
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 1026:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 1027:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1028:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1029:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1030:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]))
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, [], 16242, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1031:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, 0]

Step 1032:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 1033:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"]]

Step 1034:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696)]

Step 1035:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696), []]

Step 1036:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 1037:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 })
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 1038:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 1039:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1040:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1041:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])], PC(696)); push result (?PC(696)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], ?PC(696)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1042:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"]) --> add({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]))
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], [], 16418, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1043:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 1044:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 1045:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 1046:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["lock"], False]

Step 1047:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 1048:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T1: game_umpire(?thegame)
mode:  runnable
stack: ['?thegame']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 blocked player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=1032 blocked player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=1032 blocked player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T6: pc=1032 blocked player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1032 blocked player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1, 2 ] }
state id: 487053
================================================

Step 1049:
  program counter:   1614
  hvm code:          Frame game_umpire(g)
  explanation:       pop argument (?thegame), assign to g, and run method "game_umpire"
  module:            game
  start statement:   line=8 column=1
  end statement:     line=8 column=19
  source code:       def game_umpire(g):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1050:
  program counter:   1615
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=9 column=5
  end statement:     line=9 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, ?thegame]

Step 1051:
  program counter:   1616
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, ?thegame, "lock"]

Step 1052:
  program counter:   1617
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, ?thegame["lock"]]

Step 1053:
  program counter:   1618
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 25890, ?thegame["lock"]]

Step 1054:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 25890, { "g": ?thegame }]

Step 1055:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        game_umpire(?thegame) --> acquire(?thegame["lock"])

Step 1056:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 1057:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 25890, { "g": ?thegame }, ?thegame["lock"]]

Step 1058:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 25890, { "g": ?thegame }, False]

Step 1059:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 25890, { "g": ?thegame }, True]

Step 1060:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25890, { "g": ?thegame }]

Step 1061:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 1062:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1063:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 25890, { "g": ?thegame }, ?thegame["lock"]]

Step 1064:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 1065:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 25890, { "g": ?thegame }, ?thegame["lock"], True]

Step 1066:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  stack:             [{:}, [], 25890, { "g": ?thegame }]

Step 1067:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1068:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, None]

Step 1069:
  program counter:   1619
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=9 column=5
  end statement:     line=9 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1070:
  program counter:   1620
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=10 column=5
  end statement:     line=10 column=15
  source code:       while True:
                           ^^^^
  stack:             [{:}, True]

Step 1071:
  program counter:   1621
  hvm code:          JumpCond False 1751
  explanation:       pop value (True), compare to False, and jump to 1751 if the same
  source code:       while True:
                     ^^^^^
  stack:             [{:}]

Step 1072:
  program counter:   1622
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=13 column=9
  end statement:     line=13 column=84
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                ^
  stack:             [{:}, ?thegame]

Step 1073:
  program counter:   1623
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                   ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1074:
  program counter:   1624
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1075:
  program counter:   1625
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3, 5, 4, 1, 2])
  start expression:  line=13 column=20
  end expression:    line=13 column=29
  call trace:        game_umpire(?thegame)
  stack:             [{:}, [ 6, 3, 5, 4, 1, 2 ]]

Step 1076:
  program counter:   1626
  hvm code:          1-ary len
  explanation:       pop a value ([6, 3, 5, 4, 1, 2]); compute the length of the list; push result (6)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                            ^^^^^^^^^^^^^^^
  stack:             [{:}, 6]

Step 1077:
  program counter:   1627
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                              ^
  stack:             [{:}, 6, 2]

Step 1078:
  program counter:   1628
  hvm code:          2-ary <
  explanation:       pop 2 values (2, 6); check if second value is less than the first; push result (False)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                            ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 1079:
  program counter:   1629
  hvm code:          JumpCond True 1646
  explanation:       pop value (False), compare to True, and jump to 1646 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1080:
  program counter:   1630
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                         ^
  stack:             [{:}, ?thegame]

Step 1081:
  program counter:   1631
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                            ^^^^^
  stack:             [{:}, ?thegame, "team1"]

Step 1082:
  program counter:   1632
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                         ^^^^^^^^
  stack:             [{:}, ?thegame["team1"]]

Step 1083:
  program counter:   1633
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=13 column=45
  end expression:    line=13 column=52
  call trace:        game_umpire(?thegame)
  stack:             [{:}, {}]

Step 1084:
  program counter:   1634
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                     ^^^^^^^^^^^^^
  stack:             [{:}, 0]

Step 1085:
  program counter:   1635
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                      ^
  stack:             [{:}, 0, 0]

Step 1086:
  program counter:   1636
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 1087:
  program counter:   1637
  hvm code:          JumpCond True 1646
  explanation:       pop value (False), compare to True, and jump to 1646 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1088:
  program counter:   1638
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                 ^
  stack:             [{:}, ?thegame]

Step 1089:
  program counter:   1639
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                    ^^^^^
  stack:             [{:}, ?thegame, "team2"]

Step 1090:
  program counter:   1640
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                 ^^^^^^^^
  stack:             [{:}, ?thegame["team2"]]

Step 1091:
  program counter:   1641
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=13 column=69
  end expression:    line=13 column=76
  call trace:        game_umpire(?thegame)
  stack:             [{:}, {}]

Step 1092:
  program counter:   1642
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                             ^^^^^^^^^^^^^
  stack:             [{:}, 0]

Step 1093:
  program counter:   1643
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                              ^
  stack:             [{:}, 0, 0]

Step 1094:
  program counter:   1644
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                             ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 1095:
  program counter:   1645
  hvm code:          Jump 1647
  explanation:       set program counter to 1647
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                 ^^

Step 1096:
  program counter:   1647
  hvm code:          JumpCond False 1660
  explanation:       pop value (False), compare to False, and jump to 1660 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                     ^^^^^
  stack:             [{:}]

Step 1097:
  program counter:   1660
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=17 column=9
  end statement:     line=17 column=67
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                             ^
  stack:             [{:}, ?thegame]

Step 1098:
  program counter:   1661
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1099:
  program counter:   1662
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                             ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1100:
  program counter:   1663
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3, 5, 4, 1, 2])
  start expression:  line=17 column=33
  end expression:    line=17 column=42
  call trace:        game_umpire(?thegame)
  stack:             [{:}, [ 6, 3, 5, 4, 1, 2 ]]

Step 1101:
  program counter:   1664
  hvm code:          1-ary len
  explanation:       pop a value ([6, 3, 5, 4, 1, 2]); compute the length of the list; push result (6)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                         ^^^^^^^^^^^^^^^
  stack:             [{:}, 6]

Step 1102:
  program counter:   1665
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                ^
  stack:             [{:}, 6, ?thegame]

Step 1103:
  program counter:   1666
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                   ^^^^^^^
  stack:             [{:}, 6, ?thegame, "waiting"]

Step 1104:
  program counter:   1667
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                ^^^^^^^^^^
  stack:             [{:}, 6, ?thegame["waiting"]]

Step 1105:
  program counter:   1668
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([6, 3, 5, 4, 1, 2])
  start expression:  line=17 column=52
  end expression:    line=17 column=61
  call trace:        game_umpire(?thegame)
  stack:             [{:}, 6, [ 6, 3, 5, 4, 1, 2 ]]

Step 1106:
  program counter:   1669
  hvm code:          1-ary len
  explanation:       pop a value ([6, 3, 5, 4, 1, 2]); compute the length of the list; push result (6)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                            ^^^^^^^^^^^^^^^
  stack:             [{:}, 6, 6]

Step 1107:
  program counter:   1670
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                              ^
  stack:             [{:}, 6, 6, 2]

Step 1108:
  program counter:   1671
  hvm code:          2-ary %
  explanation:       pop 2 values (2, 6); second value modulo the first; push result (0)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                            ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 6, 0]

Step 1109:
  program counter:   1672
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 6); the second integer minus the first; push result (6)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 6]

Step 1110:
  program counter:   1673
  hvm code:          StoreVar pairedplayers
  explanation:       pop value (6) and store locally in variable \"pairedplayers\"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, pairedplayers: 6 }
  stack:             [{:}]

Step 1111:
  program counter:   1674
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=18 column=13
  end statement:     line=18 column=21
  source code:       var i = 0
                             ^
  stack:             [{:}, 0]

Step 1112:
  program counter:   1675
  hvm code:          StoreVar i
  explanation:       pop value (0) and store locally in variable \"i\"
  source code:       var i = 0
                     ^^^^^^^^^
  method variables:  { g: ?thegame, i: 0, pairedplayers: 6 }
  stack:             [{:}]

Step 1113:
  program counter:   1676
  hvm code:          LoadVar i
  explanation:       push value (0) of variable "i"
  start statement:   line=19 column=13
  end statement:     line=19 column=36
  source code:       while i < pairedplayers:
                           ^
  stack:             [{:}, 0]

Step 1114:
  program counter:   1677
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while i < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 0, 6]

Step 1115:
  program counter:   1678
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 0); check if second value is less than the first; push result (True)
  source code:       while i < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1116:
  program counter:   1679
  hvm code:          JumpCond False 1724
  explanation:       pop value (True), compare to False, and jump to 1724 if the same
  source code:       while i < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1117:
  program counter:   1680
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=20 column=17
  end statement:     line=20 column=55
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^
  stack:             [{:}, ?thegame]

Step 1118:
  program counter:   1681
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                        ^^^^^
  stack:             [{:}, ?thegame, "team1"]

Step 1119:
  program counter:   1682
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^^^^^^^^
  stack:             [{:}, ?thegame["team1"]]

Step 1120:
  program counter:   1683
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], []]

Step 1121:
  program counter:   1684
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^
  stack:             [{:}, ?thegame["team1"], [], ?thegame]

Step 1122:
  program counter:   1685
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                       ^^^^^
  stack:             [{:}, ?thegame["team1"], [], ?thegame, "team1"]

Step 1123:
  program counter:   1686
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [], ?thegame["team1"]]

Step 1124:
  program counter:   1687
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=20 column=32
  end expression:    line=20 column=39
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], [], {}]

Step 1125:
  program counter:   1688
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({}, []); insert first value into the second; push result ([{}])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ {} ]]

Step 1126:
  program counter:   1689
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^
  stack:             [{:}, ?thegame["team1"], [ {} ], ?thegame]

Step 1127:
  program counter:   1690
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                                 ^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ {} ], ?thegame, "waiting"]

Step 1128:
  program counter:   1691
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ {} ], ?thegame["waiting"]]

Step 1129:
  program counter:   1692
  hvm code:          LoadVar i
  explanation:       push value (0) of variable "i"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                                         ^
  stack:             [{:}, ?thegame["team1"], [ {} ], ?thegame["waiting"], 0]

Step 1130:
  program counter:   1693
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ {} ], ?thegame["waiting"][0]]

Step 1131:
  program counter:   1694
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"][0]) and push value (6)
  start expression:  line=20 column=42
  end expression:    line=20 column=54
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], [ {} ], 6]

Step 1132:
  program counter:   1695
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (6, [{}]); insert first value into the second; push result ([{}, 6])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ {}, 6 ]]

Step 1133:
  program counter:   1696
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{}, 6]) and call method (1294: "add")
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> add({}, 6)
  stack:             [{:}, ?thegame["team1"], [], 27138, [ {}, 6 ]]

Step 1134:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{}, 6]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 6, s: {} }
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }]

Step 1135:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 1136:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({}) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}]

Step 1137:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 6 }

Step 1138:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}, {}]

Step 1139:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (6) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}, {}, 6]

Step 1140:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 1141:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (6, {}); insert first value into the second; push result ({ 6 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}, { 6 }]

Step 1142:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 6 }, {}); union; push result ({ 6 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, { 6 }]

Step 1143:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 6 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 6 } }
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 0, "pairedplayers": 6 }]

Step 1144:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, i: 0, pairedplayers: 6 }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], { 6 }]

Step 1145:
  program counter:   1697
  hvm code:          Store
  explanation:       pop value ({ 6 }) and address (?thegame["team1"]) and store
  module:            game
  start statement:   line=20 column=17
  end statement:     line=20 column=55
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 6 }, "team2": {}, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1146:
  program counter:   1698
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=21 column=17
  end statement:     line=21 column=57
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^
  stack:             [{:}, ?thegame]

Step 1147:
  program counter:   1699
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                        ^^^^^
  stack:             [{:}, ?thegame, "team2"]

Step 1148:
  program counter:   1700
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^^^^^^^^
  stack:             [{:}, ?thegame["team2"]]

Step 1149:
  program counter:   1701
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], []]

Step 1150:
  program counter:   1702
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^
  stack:             [{:}, ?thegame["team2"], [], ?thegame]

Step 1151:
  program counter:   1703
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                       ^^^^^
  stack:             [{:}, ?thegame["team2"], [], ?thegame, "team2"]

Step 1152:
  program counter:   1704
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [], ?thegame["team2"]]

Step 1153:
  program counter:   1705
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=21 column=32
  end expression:    line=21 column=39
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], [], {}]

Step 1154:
  program counter:   1706
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({}, []); insert first value into the second; push result ([{}])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ {} ]]

Step 1155:
  program counter:   1707
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame]

Step 1156:
  program counter:   1708
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                 ^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame, "waiting"]

Step 1157:
  program counter:   1709
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame["waiting"]]

Step 1158:
  program counter:   1710
  hvm code:          LoadVar i
  explanation:       push value (0) of variable "i"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                         ^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame["waiting"], 0]

Step 1159:
  program counter:   1711
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                           ^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame["waiting"], 0, 1]

Step 1160:
  program counter:   1712
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                         ^^^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame["waiting"], 1]

Step 1161:
  program counter:   1713
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?thegame["waiting"]); push result (?thegame["waiting"][1])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ {} ], ?thegame["waiting"][1]]

Step 1162:
  program counter:   1714
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"][1]) and push value (3)
  start expression:  line=21 column=42
  end expression:    line=21 column=56
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], [ {} ], 3]

Step 1163:
  program counter:   1715
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (3, [{}]); insert first value into the second; push result ([{}, 3])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ {}, 3 ]]

Step 1164:
  program counter:   1716
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{}, 3]) and call method (1294: "add")
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> add({}, 3)
  stack:             [{:}, ?thegame["team2"], [], 27458, [ {}, 3 ]]

Step 1165:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{}, 3]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 3, s: {} }
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }]

Step 1166:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 1167:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({}) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}]

Step 1168:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 3 }

Step 1169:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}, {}]

Step 1170:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (3) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}, {}, 3]

Step 1171:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 1172:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (3, {}); insert first value into the second; push result ({ 3 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, {}, { 3 }]

Step 1173:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 3 }, {}); union; push result ({ 3 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }, { 3 }]

Step 1174:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 3 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 3 } }
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 0, "pairedplayers": 6 }]

Step 1175:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, i: 0, pairedplayers: 6 }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], { 3 }]

Step 1176:
  program counter:   1717
  hvm code:          Store
  explanation:       pop value ({ 3 }) and address (?thegame["team2"]) and store
  module:            game
  start statement:   line=21 column=17
  end statement:     line=21 column=57
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 6 }, "team2": { 3 }, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1177:
  program counter:   1718
  hvm code:          LoadVar i
  explanation:       push value (0) of variable "i"
  start statement:   line=22 column=17
  end statement:     line=22 column=22
  source code:       i += 2
                     ^^^^^^
  stack:             [{:}, 0]

Step 1178:
  program counter:   1719
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=22 column=17
  end expression:    line=22 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1179:
  program counter:   1720
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       i += 2
                          ^
  stack:             [{:}, 0, 2]

Step 1180:
  program counter:   1721
  hvm code:          2-ary +
  explanation:       pop 2 values (2, 0); add the integers; push result (2)
  source code:       i += 2
                     ^^^^^^
  stack:             [{:}, 2]

Step 1181:
  program counter:   1722
  hvm code:          StoreVar i
  explanation:       pop value (2) and store locally in variable \"i\"
  source code:       i += 2
                     ^^^^
  method variables:  { g: ?thegame, i: 2, pairedplayers: 6 }
  stack:             [{:}]

Step 1182:
  program counter:   1723
  hvm code:          Jump 1676
  explanation:       set program counter to 1676
  start statement:   line=19 column=13
  end statement:     line=19 column=36
  source code:       while i < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1183:
  program counter:   1676
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       while i < pairedplayers:
                           ^
  stack:             [{:}, 2]

Step 1184:
  program counter:   1677
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while i < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 2, 6]

Step 1185:
  program counter:   1678
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 2); check if second value is less than the first; push result (True)
  source code:       while i < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1186:
  program counter:   1679
  hvm code:          JumpCond False 1724
  explanation:       pop value (True), compare to False, and jump to 1724 if the same
  source code:       while i < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1187:
  program counter:   1680
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=20 column=17
  end statement:     line=20 column=55
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^
  stack:             [{:}, ?thegame]

Step 1188:
  program counter:   1681
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                        ^^^^^
  stack:             [{:}, ?thegame, "team1"]

Step 1189:
  program counter:   1682
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^^^^^^^^
  stack:             [{:}, ?thegame["team1"]]

Step 1190:
  program counter:   1683
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], []]

Step 1191:
  program counter:   1684
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^
  stack:             [{:}, ?thegame["team1"], [], ?thegame]

Step 1192:
  program counter:   1685
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                       ^^^^^
  stack:             [{:}, ?thegame["team1"], [], ?thegame, "team1"]

Step 1193:
  program counter:   1686
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [], ?thegame["team1"]]

Step 1194:
  program counter:   1687
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 6 })
  start expression:  line=20 column=32
  end expression:    line=20 column=39
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], [], { 6 }]

Step 1195:
  program counter:   1688
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 6 }, []); insert first value into the second; push result ([{ 6 }])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 6 } ]]

Step 1196:
  program counter:   1689
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^
  stack:             [{:}, ?thegame["team1"], [ { 6 } ], ?thegame]

Step 1197:
  program counter:   1690
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                                 ^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 6 } ], ?thegame, "waiting"]

Step 1198:
  program counter:   1691
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 6 } ], ?thegame["waiting"]]

Step 1199:
  program counter:   1692
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                                         ^
  stack:             [{:}, ?thegame["team1"], [ { 6 } ], ?thegame["waiting"], 2]

Step 1200:
  program counter:   1693
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (2, ?thegame["waiting"]); push result (?thegame["waiting"][2])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 6 } ], ?thegame["waiting"][2]]

Step 1201:
  program counter:   1694
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"][2]) and push value (5)
  start expression:  line=20 column=42
  end expression:    line=20 column=54
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], [ { 6 } ], 5]

Step 1202:
  program counter:   1695
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (5, [{ 6 }]); insert first value into the second; push result ([{ 6 }, 5])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 6 }, 5 ]]

Step 1203:
  program counter:   1696
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{ 6 }, 5]) and call method (1294: "add")
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> add({ 6 }, 5)
  stack:             [{:}, ?thegame["team1"], [], 27138, [ { 6 }, 5 ]]

Step 1204:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{ 6 }, 5]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 5, s: { 6 } }
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }]

Step 1205:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 1206:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({ 6 }) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 6 }]

Step 1207:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 5 }

Step 1208:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 6 }, {}]

Step 1209:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (5) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 6 }, {}, 5]

Step 1210:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 1211:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (5, {}); insert first value into the second; push result ({ 5 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 6 }, { 5 }]

Step 1212:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 5 }, { 6 }); union; push result ({ 5, 6 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 5, 6 }]

Step 1213:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 5, 6 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 5, 6 } }
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 2, "pairedplayers": 6 }]

Step 1214:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, i: 2, pairedplayers: 6 }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], { 5, 6 }]

Step 1215:
  program counter:   1697
  hvm code:          Store
  explanation:       pop value ({ 5, 6 }) and address (?thegame["team1"]) and store
  module:            game
  start statement:   line=20 column=17
  end statement:     line=20 column=55
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 5, 6 }, "team2": { 3 }, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1216:
  program counter:   1698
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=21 column=17
  end statement:     line=21 column=57
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^
  stack:             [{:}, ?thegame]

Step 1217:
  program counter:   1699
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                        ^^^^^
  stack:             [{:}, ?thegame, "team2"]

Step 1218:
  program counter:   1700
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^^^^^^^^
  stack:             [{:}, ?thegame["team2"]]

Step 1219:
  program counter:   1701
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], []]

Step 1220:
  program counter:   1702
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^
  stack:             [{:}, ?thegame["team2"], [], ?thegame]

Step 1221:
  program counter:   1703
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                       ^^^^^
  stack:             [{:}, ?thegame["team2"], [], ?thegame, "team2"]

Step 1222:
  program counter:   1704
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [], ?thegame["team2"]]

Step 1223:
  program counter:   1705
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 3 })
  start expression:  line=21 column=32
  end expression:    line=21 column=39
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], [], { 3 }]

Step 1224:
  program counter:   1706
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 3 }, []); insert first value into the second; push result ([{ 3 }])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ]]

Step 1225:
  program counter:   1707
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame]

Step 1226:
  program counter:   1708
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                 ^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame, "waiting"]

Step 1227:
  program counter:   1709
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame["waiting"]]

Step 1228:
  program counter:   1710
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                         ^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame["waiting"], 2]

Step 1229:
  program counter:   1711
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                           ^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame["waiting"], 2, 1]

Step 1230:
  program counter:   1712
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 2); add the integers; push result (3)
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                         ^^^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame["waiting"], 3]

Step 1231:
  program counter:   1713
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (3, ?thegame["waiting"]); push result (?thegame["waiting"][3])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], ?thegame["waiting"][3]]

Step 1232:
  program counter:   1714
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"][3]) and push value (4)
  start expression:  line=21 column=42
  end expression:    line=21 column=56
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], [ { 3 } ], 4]

Step 1233:
  program counter:   1715
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (4, [{ 3 }]); insert first value into the second; push result ([{ 3 }, 4])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3 }, 4 ]]

Step 1234:
  program counter:   1716
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{ 3 }, 4]) and call method (1294: "add")
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> add({ 3 }, 4)
  stack:             [{:}, ?thegame["team2"], [], 27458, [ { 3 }, 4 ]]

Step 1235:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{ 3 }, 4]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 4, s: { 3 } }
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }]

Step 1236:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 1237:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({ 3 }) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 3 }]

Step 1238:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 4 }

Step 1239:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 3 }, {}]

Step 1240:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (4) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 3 }, {}, 4]

Step 1241:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 1242:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (4, {}); insert first value into the second; push result ({ 4 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 3 }, { 4 }]

Step 1243:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 4 }, { 3 }); union; push result ({ 3, 4 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }, { 3, 4 }]

Step 1244:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 3, 4 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 3, 4 } }
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 2, "pairedplayers": 6 }]

Step 1245:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, i: 2, pairedplayers: 6 }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], { 3, 4 }]

Step 1246:
  program counter:   1717
  hvm code:          Store
  explanation:       pop value ({ 3, 4 }) and address (?thegame["team2"]) and store
  module:            game
  start statement:   line=21 column=17
  end statement:     line=21 column=57
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 5, 6 }, "team2": { 3, 4 }, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1247:
  program counter:   1718
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  start statement:   line=22 column=17
  end statement:     line=22 column=22
  source code:       i += 2
                     ^^^^^^
  stack:             [{:}, 2]

Step 1248:
  program counter:   1719
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=22 column=17
  end expression:    line=22 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1249:
  program counter:   1720
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       i += 2
                          ^
  stack:             [{:}, 2, 2]

Step 1250:
  program counter:   1721
  hvm code:          2-ary +
  explanation:       pop 2 values (2, 2); add the integers; push result (4)
  source code:       i += 2
                     ^^^^^^
  stack:             [{:}, 4]

Step 1251:
  program counter:   1722
  hvm code:          StoreVar i
  explanation:       pop value (4) and store locally in variable \"i\"
  source code:       i += 2
                     ^^^^
  method variables:  { g: ?thegame, i: 4, pairedplayers: 6 }
  stack:             [{:}]

Step 1252:
  program counter:   1723
  hvm code:          Jump 1676
  explanation:       set program counter to 1676
  start statement:   line=19 column=13
  end statement:     line=19 column=36
  source code:       while i < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1253:
  program counter:   1676
  hvm code:          LoadVar i
  explanation:       push value (4) of variable "i"
  source code:       while i < pairedplayers:
                           ^
  stack:             [{:}, 4]

Step 1254:
  program counter:   1677
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while i < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 4, 6]

Step 1255:
  program counter:   1678
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 4); check if second value is less than the first; push result (True)
  source code:       while i < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1256:
  program counter:   1679
  hvm code:          JumpCond False 1724
  explanation:       pop value (True), compare to False, and jump to 1724 if the same
  source code:       while i < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1257:
  program counter:   1680
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=20 column=17
  end statement:     line=20 column=55
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^
  stack:             [{:}, ?thegame]

Step 1258:
  program counter:   1681
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                        ^^^^^
  stack:             [{:}, ?thegame, "team1"]

Step 1259:
  program counter:   1682
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^^^^^^^^
  stack:             [{:}, ?thegame["team1"]]

Step 1260:
  program counter:   1683
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], []]

Step 1261:
  program counter:   1684
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^
  stack:             [{:}, ?thegame["team1"], [], ?thegame]

Step 1262:
  program counter:   1685
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                       ^^^^^
  stack:             [{:}, ?thegame["team1"], [], ?thegame, "team1"]

Step 1263:
  program counter:   1686
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [], ?thegame["team1"]]

Step 1264:
  program counter:   1687
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 5, 6 })
  start expression:  line=20 column=32
  end expression:    line=20 column=39
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], [], { 5, 6 }]

Step 1265:
  program counter:   1688
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 5, 6 }, []); insert first value into the second; push result ([{ 5, 6 }])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ]]

Step 1266:
  program counter:   1689
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ], ?thegame]

Step 1267:
  program counter:   1690
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                                 ^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ], ?thegame, "waiting"]

Step 1268:
  program counter:   1691
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ], ?thegame["waiting"]]

Step 1269:
  program counter:   1692
  hvm code:          LoadVar i
  explanation:       push value (4) of variable "i"
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                                         ^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ], ?thegame["waiting"], 4]

Step 1270:
  program counter:   1693
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (4, ?thegame["waiting"]); push result (?thegame["waiting"][4])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                              ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ], ?thegame["waiting"][4]]

Step 1271:
  program counter:   1694
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"][4]) and push value (1)
  start expression:  line=20 column=42
  end expression:    line=20 column=54
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 } ], 1]

Step 1272:
  program counter:   1695
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [{ 5, 6 }]); insert first value into the second; push result ([{ 5, 6 }, 1])
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                    ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [ { 5, 6 }, 1 ]]

Step 1273:
  program counter:   1696
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{ 5, 6 }, 1]) and call method (1294: "add")
  source code:       g->team1 = add(g->team1, g->waiting[i])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> add({ 5, 6 }, 1)
  stack:             [{:}, ?thegame["team1"], [], 27138, [ { 5, 6 }, 1 ]]

Step 1274:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{ 5, 6 }, 1]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 1, s: { 5, 6 } }
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }]

Step 1275:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 1276:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({ 5, 6 }) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 5, 6 }]

Step 1277:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 1 }

Step 1278:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 5, 6 }, {}]

Step 1279:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (1) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 5, 6 }, {}, 1]

Step 1280:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 1281:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (1, {}); insert first value into the second; push result ({ 1 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 5, 6 }, { 1 }]

Step 1282:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 1 }, { 5, 6 }); union; push result ({ 1, 5, 6 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 1, 5, 6 }]

Step 1283:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 1, 5, 6 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 1, 5, 6 } }
  stack:             [{:}, ?thegame["team1"], [], 27138, { "g": ?thegame, "i": 4, "pairedplayers": 6 }]

Step 1284:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, i: 4, pairedplayers: 6 }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team1"], { 1, 5, 6 }]

Step 1285:
  program counter:   1697
  hvm code:          Store
  explanation:       pop value ({ 1, 5, 6 }) and address (?thegame["team1"]) and store
  module:            game
  start statement:   line=20 column=17
  end statement:     line=20 column=55
  source code:       g->team1 = add(g->team1, g->waiting[i])
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 3, 4 }, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1286:
  program counter:   1698
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=21 column=17
  end statement:     line=21 column=57
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^
  stack:             [{:}, ?thegame]

Step 1287:
  program counter:   1699
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                        ^^^^^
  stack:             [{:}, ?thegame, "team2"]

Step 1288:
  program counter:   1700
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^^^^^^^^
  stack:             [{:}, ?thegame["team2"]]

Step 1289:
  program counter:   1701
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], []]

Step 1290:
  program counter:   1702
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^
  stack:             [{:}, ?thegame["team2"], [], ?thegame]

Step 1291:
  program counter:   1703
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                       ^^^^^
  stack:             [{:}, ?thegame["team2"], [], ?thegame, "team2"]

Step 1292:
  program counter:   1704
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [], ?thegame["team2"]]

Step 1293:
  program counter:   1705
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 3, 4 })
  start expression:  line=21 column=32
  end expression:    line=21 column=39
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], [], { 3, 4 }]

Step 1294:
  program counter:   1706
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 3, 4 }, []); insert first value into the second; push result ([{ 3, 4 }])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ]]

Step 1295:
  program counter:   1707
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame]

Step 1296:
  program counter:   1708
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                 ^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame, "waiting"]

Step 1297:
  program counter:   1709
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame["waiting"]]

Step 1298:
  program counter:   1710
  hvm code:          LoadVar i
  explanation:       push value (4) of variable "i"
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                         ^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame["waiting"], 4]

Step 1299:
  program counter:   1711
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                           ^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame["waiting"], 4, 1]

Step 1300:
  program counter:   1712
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 4); add the integers; push result (5)
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                                         ^^^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame["waiting"], 5]

Step 1301:
  program counter:   1713
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (5, ?thegame["waiting"]); push result (?thegame["waiting"][5])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                              ^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], ?thegame["waiting"][5]]

Step 1302:
  program counter:   1714
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"][5]) and push value (2)
  start expression:  line=21 column=42
  end expression:    line=21 column=56
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 } ], 2]

Step 1303:
  program counter:   1715
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [{ 3, 4 }]); insert first value into the second; push result ([{ 3, 4 }, 2])
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [ { 3, 4 }, 2 ]]

Step 1304:
  program counter:   1716
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{ 3, 4 }, 2]) and call method (1294: "add")
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> add({ 3, 4 }, 2)
  stack:             [{:}, ?thegame["team2"], [], 27458, [ { 3, 4 }, 2 ]]

Step 1305:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{ 3, 4 }, 2]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 2, s: { 3, 4 } }
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }]

Step 1306:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 1307:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({ 3, 4 }) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 3, 4 }]

Step 1308:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 2 }

Step 1309:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 3, 4 }, {}]

Step 1310:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (2) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 3, 4 }, {}, 2]

Step 1311:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 1312:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (2, {}); insert first value into the second; push result ({ 2 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 3, 4 }, { 2 }]

Step 1313:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 2 }, { 3, 4 }); union; push result ({ 2, 3, 4 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }, { 2, 3, 4 }]

Step 1314:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 2, 3, 4 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 2, 3, 4 } }
  stack:             [{:}, ?thegame["team2"], [], 27458, { "g": ?thegame, "i": 4, "pairedplayers": 6 }]

Step 1315:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, i: 4, pairedplayers: 6 }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, ?thegame["team2"], { 2, 3, 4 }]

Step 1316:
  program counter:   1717
  hvm code:          Store
  explanation:       pop value ({ 2, 3, 4 }) and address (?thegame["team2"]) and store
  module:            game
  start statement:   line=21 column=17
  end statement:     line=21 column=57
  source code:       g->team2 = add(g->team2, g->waiting[i+1])
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [ 6, 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1317:
  program counter:   1718
  hvm code:          LoadVar i
  explanation:       push value (4) of variable "i"
  start statement:   line=22 column=17
  end statement:     line=22 column=22
  source code:       i += 2
                     ^^^^^^
  stack:             [{:}, 4]

Step 1318:
  program counter:   1719
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=22 column=17
  end expression:    line=22 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1319:
  program counter:   1720
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       i += 2
                          ^
  stack:             [{:}, 4, 2]

Step 1320:
  program counter:   1721
  hvm code:          2-ary +
  explanation:       pop 2 values (2, 4); add the integers; push result (6)
  source code:       i += 2
                     ^^^^^^
  stack:             [{:}, 6]

Step 1321:
  program counter:   1722
  hvm code:          StoreVar i
  explanation:       pop value (6) and store locally in variable \"i\"
  source code:       i += 2
                     ^^^^
  method variables:  { g: ?thegame, i: 6, pairedplayers: 6 }
  stack:             [{:}]

Step 1322:
  program counter:   1723
  hvm code:          Jump 1676
  explanation:       set program counter to 1676
  start statement:   line=19 column=13
  end statement:     line=19 column=36
  source code:       while i < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1323:
  program counter:   1676
  hvm code:          LoadVar i
  explanation:       push value (6) of variable "i"
  source code:       while i < pairedplayers:
                           ^
  stack:             [{:}, 6]

Step 1324:
  program counter:   1677
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while i < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 6, 6]

Step 1325:
  program counter:   1678
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 6); check if second value is less than the first; push result (False)
  source code:       while i < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 1326:
  program counter:   1679
  hvm code:          JumpCond False 1724
  explanation:       pop value (False), compare to False, and jump to 1724 if the same
  source code:       while i < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1327:
  program counter:   1724
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=24 column=13
  end statement:     line=24 column=21
  source code:       var j = 0
                             ^
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1328:
  program counter:   1725
  hvm code:          Push 0
  explanation:       push constant 0
  start expression:  line=24 column=21
  end expression:    line=24 column=21
  stack:             [{:}, 0]

Step 1329:
  program counter:   1726
  hvm code:          StoreVar j
  explanation:       pop value (0) and store locally in variable \"j\"
  source code:       var j = 0
                     ^^^^^^^^^
  method variables:  { g: ?thegame, j: 0, pairedplayers: 6 }
  stack:             [{:}]

Step 1330:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (0) of variable "j"
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 0]

Step 1331:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 0, 6]

Step 1332:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 0); check if second value is less than the first; push result (True)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1333:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (True), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1334:
  program counter:   1731
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=26 column=17
  end statement:     line=26 column=33
  source code:       del g->waiting[0]
                         ^
  stack:             [{:}, ?thegame]

Step 1335:
  program counter:   1732
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       del g->waiting[0]
                            ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1336:
  program counter:   1733
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1337:
  program counter:   1734
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       del g->waiting[0]
                                    ^
  stack:             [{:}, ?thegame["waiting"], 0]

Step 1338:
  program counter:   1735
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"][0]]

Step 1339:
  program counter:   1736
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del g->waiting[0]
                     ^^^^^^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [ 3, 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1340:
  program counter:   1737
  hvm code:          LoadVar j
  explanation:       push value (0) of variable "j"
  start statement:   line=27 column=17
  end statement:     line=27 column=22
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 0]

Step 1341:
  program counter:   1738
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=27 column=17
  end expression:    line=27 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1342:
  program counter:   1739
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       j += 1
                          ^
  stack:             [{:}, 0, 1]

Step 1343:
  program counter:   1740
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 1]

Step 1344:
  program counter:   1741
  hvm code:          StoreVar j
  explanation:       pop value (1) and store locally in variable \"j\"
  source code:       j += 1
                     ^^^^
  method variables:  { g: ?thegame, j: 1, pairedplayers: 6 }
  stack:             [{:}]

Step 1345:
  program counter:   1742
  hvm code:          Jump 1727
  explanation:       set program counter to 1727
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1346:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (1) of variable "j"
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 1]

Step 1347:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 1, 6]

Step 1348:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 1); check if second value is less than the first; push result (True)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1349:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (True), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1350:
  program counter:   1731
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=26 column=17
  end statement:     line=26 column=33
  source code:       del g->waiting[0]
                         ^
  stack:             [{:}, ?thegame]

Step 1351:
  program counter:   1732
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       del g->waiting[0]
                            ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1352:
  program counter:   1733
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1353:
  program counter:   1734
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       del g->waiting[0]
                                    ^
  stack:             [{:}, ?thegame["waiting"], 0]

Step 1354:
  program counter:   1735
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"][0]]

Step 1355:
  program counter:   1736
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del g->waiting[0]
                     ^^^^^^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [ 5, 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1356:
  program counter:   1737
  hvm code:          LoadVar j
  explanation:       push value (1) of variable "j"
  start statement:   line=27 column=17
  end statement:     line=27 column=22
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 1]

Step 1357:
  program counter:   1738
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=27 column=17
  end expression:    line=27 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1358:
  program counter:   1739
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       j += 1
                          ^
  stack:             [{:}, 1, 1]

Step 1359:
  program counter:   1740
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 2]

Step 1360:
  program counter:   1741
  hvm code:          StoreVar j
  explanation:       pop value (2) and store locally in variable \"j\"
  source code:       j += 1
                     ^^^^
  method variables:  { g: ?thegame, j: 2, pairedplayers: 6 }
  stack:             [{:}]

Step 1361:
  program counter:   1742
  hvm code:          Jump 1727
  explanation:       set program counter to 1727
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1362:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (2) of variable "j"
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 2]

Step 1363:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 2, 6]

Step 1364:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 2); check if second value is less than the first; push result (True)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1365:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (True), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1366:
  program counter:   1731
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=26 column=17
  end statement:     line=26 column=33
  source code:       del g->waiting[0]
                         ^
  stack:             [{:}, ?thegame]

Step 1367:
  program counter:   1732
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       del g->waiting[0]
                            ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1368:
  program counter:   1733
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1369:
  program counter:   1734
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       del g->waiting[0]
                                    ^
  stack:             [{:}, ?thegame["waiting"], 0]

Step 1370:
  program counter:   1735
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"][0]]

Step 1371:
  program counter:   1736
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del g->waiting[0]
                     ^^^^^^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [ 4, 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1372:
  program counter:   1737
  hvm code:          LoadVar j
  explanation:       push value (2) of variable "j"
  start statement:   line=27 column=17
  end statement:     line=27 column=22
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 2]

Step 1373:
  program counter:   1738
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=27 column=17
  end expression:    line=27 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1374:
  program counter:   1739
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       j += 1
                          ^
  stack:             [{:}, 2, 1]

Step 1375:
  program counter:   1740
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 2); add the integers; push result (3)
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 3]

Step 1376:
  program counter:   1741
  hvm code:          StoreVar j
  explanation:       pop value (3) and store locally in variable \"j\"
  source code:       j += 1
                     ^^^^
  method variables:  { g: ?thegame, j: 3, pairedplayers: 6 }
  stack:             [{:}]

Step 1377:
  program counter:   1742
  hvm code:          Jump 1727
  explanation:       set program counter to 1727
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1378:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (3) of variable "j"
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 3]

Step 1379:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 3, 6]

Step 1380:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 3); check if second value is less than the first; push result (True)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1381:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (True), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1382:
  program counter:   1731
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=26 column=17
  end statement:     line=26 column=33
  source code:       del g->waiting[0]
                         ^
  stack:             [{:}, ?thegame]

Step 1383:
  program counter:   1732
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       del g->waiting[0]
                            ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1384:
  program counter:   1733
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1385:
  program counter:   1734
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       del g->waiting[0]
                                    ^
  stack:             [{:}, ?thegame["waiting"], 0]

Step 1386:
  program counter:   1735
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"][0]]

Step 1387:
  program counter:   1736
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del g->waiting[0]
                     ^^^^^^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [ 1, 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1388:
  program counter:   1737
  hvm code:          LoadVar j
  explanation:       push value (3) of variable "j"
  start statement:   line=27 column=17
  end statement:     line=27 column=22
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 3]

Step 1389:
  program counter:   1738
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=27 column=17
  end expression:    line=27 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1390:
  program counter:   1739
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       j += 1
                          ^
  stack:             [{:}, 3, 1]

Step 1391:
  program counter:   1740
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 3); add the integers; push result (4)
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 4]

Step 1392:
  program counter:   1741
  hvm code:          StoreVar j
  explanation:       pop value (4) and store locally in variable \"j\"
  source code:       j += 1
                     ^^^^
  method variables:  { g: ?thegame, j: 4, pairedplayers: 6 }
  stack:             [{:}]

Step 1393:
  program counter:   1742
  hvm code:          Jump 1727
  explanation:       set program counter to 1727
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1394:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (4) of variable "j"
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 4]

Step 1395:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 4, 6]

Step 1396:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 4); check if second value is less than the first; push result (True)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1397:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (True), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1398:
  program counter:   1731
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=26 column=17
  end statement:     line=26 column=33
  source code:       del g->waiting[0]
                         ^
  stack:             [{:}, ?thegame]

Step 1399:
  program counter:   1732
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       del g->waiting[0]
                            ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1400:
  program counter:   1733
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1401:
  program counter:   1734
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       del g->waiting[0]
                                    ^
  stack:             [{:}, ?thegame["waiting"], 0]

Step 1402:
  program counter:   1735
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"][0]]

Step 1403:
  program counter:   1736
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del g->waiting[0]
                     ^^^^^^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [ 2 ] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1404:
  program counter:   1737
  hvm code:          LoadVar j
  explanation:       push value (4) of variable "j"
  start statement:   line=27 column=17
  end statement:     line=27 column=22
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 4]

Step 1405:
  program counter:   1738
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=27 column=17
  end expression:    line=27 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1406:
  program counter:   1739
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       j += 1
                          ^
  stack:             [{:}, 4, 1]

Step 1407:
  program counter:   1740
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 4); add the integers; push result (5)
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 5]

Step 1408:
  program counter:   1741
  hvm code:          StoreVar j
  explanation:       pop value (5) and store locally in variable \"j\"
  source code:       j += 1
                     ^^^^
  method variables:  { g: ?thegame, j: 5, pairedplayers: 6 }
  stack:             [{:}]

Step 1409:
  program counter:   1742
  hvm code:          Jump 1727
  explanation:       set program counter to 1727
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1410:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (5) of variable "j"
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 5]

Step 1411:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 5, 6]

Step 1412:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 5); check if second value is less than the first; push result (True)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1413:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (True), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1414:
  program counter:   1731
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=26 column=17
  end statement:     line=26 column=33
  source code:       del g->waiting[0]
                         ^
  stack:             [{:}, ?thegame]

Step 1415:
  program counter:   1732
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       del g->waiting[0]
                            ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1416:
  program counter:   1733
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1417:
  program counter:   1734
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       del g->waiting[0]
                                    ^
  stack:             [{:}, ?thegame["waiting"], 0]

Step 1418:
  program counter:   1735
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?thegame["waiting"]); push result (?thegame["waiting"][0])
  source code:       del g->waiting[0]
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"][0]]

Step 1419:
  program counter:   1736
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del g->waiting[0]
                     ^^^^^^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 1420:
  program counter:   1737
  hvm code:          LoadVar j
  explanation:       push value (5) of variable "j"
  start statement:   line=27 column=17
  end statement:     line=27 column=22
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 5]

Step 1421:
  program counter:   1738
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=27 column=17
  end expression:    line=27 column=22
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1422:
  program counter:   1739
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       j += 1
                          ^
  stack:             [{:}, 5, 1]

Step 1423:
  program counter:   1740
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 5); add the integers; push result (6)
  source code:       j += 1
                     ^^^^^^
  stack:             [{:}, 6]

Step 1424:
  program counter:   1741
  hvm code:          StoreVar j
  explanation:       pop value (6) and store locally in variable \"j\"
  source code:       j += 1
                     ^^^^
  method variables:  { g: ?thegame, j: 6, pairedplayers: 6 }
  stack:             [{:}]

Step 1425:
  program counter:   1742
  hvm code:          Jump 1727
  explanation:       set program counter to 1727
  start statement:   line=25 column=13
  end statement:     line=25 column=36
  source code:       while j < pairedplayers:
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 1426:
  program counter:   1727
  hvm code:          LoadVar j
  explanation:       push value (6) of variable "j"
  source code:       while j < pairedplayers:
                           ^
  stack:             [{:}, 6]

Step 1427:
  program counter:   1728
  hvm code:          LoadVar pairedplayers
  explanation:       push value (6) of variable "pairedplayers"
  source code:       while j < pairedplayers:
                               ^^^^^^^^^^^^^
  stack:             [{:}, 6, 6]

Step 1428:
  program counter:   1729
  hvm code:          2-ary <
  explanation:       pop 2 values (6, 6); check if second value is less than the first; push result (False)
  source code:       while j < pairedplayers:
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 1429:
  program counter:   1730
  hvm code:          JumpCond False 1743
  explanation:       pop value (False), compare to False, and jump to 1743 if the same
  source code:       while j < pairedplayers:
                     ^^^^^
  stack:             [{:}]

Step 1430:
  program counter:   1743
  hvm code:          DelVar j
  explanation:       delete method variable j
  start statement:   line=31 column=9
  end statement:     line=31 column=30
  source code:       notifyAll(?g->players)
                                ^
  method variables:  { g: ?thegame, pairedplayers: 6 }

Step 1431:
  program counter:   1744
  hvm code:          DelVar pairedplayers
  explanation:       delete method variable pairedplayers
  start expression:  line=31 column=20
  end expression:    line=31 column=20
  method variables:  { g: ?thegame }

Step 1432:
  program counter:   1745
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start expression:  line=31 column=20
  end expression:    line=31 column=20
  stack:             [{:}, ?thegame]

Step 1433:
  program counter:   1746
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       notifyAll(?g->players)
                                   ^^^^^^^
  stack:             [{:}, ?thegame, "players"]

Step 1434:
  program counter:   1747
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       notifyAll(?g->players)
                                ^^^^^^^^^^
  stack:             [{:}, ?thegame["players"]]

Step 1435:
  program counter:   1748
  hvm code:          Apply PC(1097)
  explanation:       pop an argument (?thegame["players"]) and call method (1097: "notifyAll")
  source code:       notifyAll(?g->players)
                     ^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> notifyAll(?thegame["players"])
  stack:             [{:}, [], 27970, ?thegame["players"]]

Step 1436:
  program counter:   1097
  hvm code:          Frame notifyAll(c)
  explanation:       pop argument (?thegame["players"]), assign to c, and run method "notifyAll"
  module:            synch
  start statement:   line=60 column=1
  end statement:     line=60 column=17
  source code:       def notifyAll(c):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"] }
  stack:             [{:}, [], 27970, { "g": ?thegame }]

Step 1437:
  program counter:   1098
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=61 column=16
  end statement:     line=61 column=31
  source code:       atomically !c = bag.empty()
                                ^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> notifyAll(?thegame["players"])

Step 1438:
  program counter:   1099
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically !c = bag.empty()
                                 ^
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"]]

Step 1439:
  program counter:   1100
  hvm code:          DelVar c
  explanation:       delete method variable c
  start expression:  line=61 column=17
  end expression:    line=61 column=17
  method variables:  { }

Step 1440:
  program counter:   1101
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically !c = bag.empty()
                                     ^^^^^^^^^
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], PC(541)]

Step 1441:
  program counter:   1102
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically !c = bag.empty()
                                              ^^
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], PC(541), []]

Step 1442:
  program counter:   1103
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically !c = bag.empty()
                                     ^^^^^^^^^^^
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], ?PC(541)[[]]]

Step 1443:
  program counter:   1104
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=61 column=21
  end expression:    line=61 column=31
  call trace:        game_umpire(?thegame) --> notifyAll(?thegame["players"]) --> empty()
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], [], 17666, []]

Step 1444:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], [], 17666, {:}]

Step 1445:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], [], 17666, {:}, {:}]

Step 1446:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], [], 17666, {:}]

Step 1447:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        game_umpire(?thegame) --> notifyAll(?thegame["players"])
  stack:             [{:}, [], 27970, { "g": ?thegame }, ?thegame["players"], {:}]

Step 1448:
  program counter:   1105
  hvm code:          Store
  explanation:       pop value ({:}) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=61 column=16
  end statement:     line=61 column=31
  source code:       atomically !c = bag.empty()
                                ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 27970, { "g": ?thegame }]

Step 1449:
  program counter:   1106
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  source code:       atomically !c = bag.empty()
                                ^^^^^^^^^^^^^^^^

Step 1450:
  program counter:   1107
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=60 column=1
  end statement:     line=60 column=17
  source code:       def notifyAll(c):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, None]

Step 1451:
  program counter:   1749
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=31 column=9
  end statement:     line=31 column=30
  source code:       notifyAll(?g->players)
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1452:
  program counter:   1750
  hvm code:          Jump 1620
  explanation:       set program counter to 1620
  start statement:   line=10 column=5
  end statement:     line=10 column=15
  source code:       while True:
                     ^^^^^^^^^^^

Step 1453:
  program counter:   1620
  hvm code:          Push True
  explanation:       push constant True
  source code:       while True:
                           ^^^^
  stack:             [{:}, True]

Step 1454:
  program counter:   1621
  hvm code:          JumpCond False 1751
  explanation:       pop value (True), compare to False, and jump to 1751 if the same
  source code:       while True:
                     ^^^^^
  stack:             [{:}]

Step 1455:
  program counter:   1622
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=13 column=9
  end statement:     line=13 column=84
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                ^
  stack:             [{:}, ?thegame]

Step 1456:
  program counter:   1623
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                   ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 1457:
  program counter:   1624
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 1458:
  program counter:   1625
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([])
  start expression:  line=13 column=20
  end expression:    line=13 column=29
  call trace:        game_umpire(?thegame)
  stack:             [{:}, []]

Step 1459:
  program counter:   1626
  hvm code:          1-ary len
  explanation:       pop a value ([]); push result (0)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                            ^^^^^^^^^^^^^^^
  stack:             [{:}, 0]

Step 1460:
  program counter:   1627
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                              ^
  stack:             [{:}, 0, 2]

Step 1461:
  program counter:   1628
  hvm code:          2-ary <
  explanation:       pop 2 values (2, 0); check if second value is less than the first; push result (True)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                            ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1462:
  program counter:   1629
  hvm code:          JumpCond True 1646
  explanation:       pop value (True), compare to True, and jump to 1646 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1463:
  program counter:   1646
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=13 column=15
  end expression:    line=13 column=83
  stack:             [{:}, True]

Step 1464:
  program counter:   1647
  hvm code:          JumpCond False 1660
  explanation:       pop value (True), compare to False, and jump to 1660 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                     ^^^^^
  stack:             [{:}]

Step 1465:
  program counter:   1648
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=14 column=13
  end statement:     line=14 column=43
  source code:       wait(?g->active_game, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 1466:
  program counter:   1649
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->active_game, ?g->lock)
                           ^
  stack:             [{:}, [], ?thegame]

Step 1467:
  program counter:   1650
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       wait(?g->active_game, ?g->lock)
                              ^^^^^^^^^^^
  stack:             [{:}, [], ?thegame, "active_game"]

Step 1468:
  program counter:   1651
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       wait(?g->active_game, ?g->lock)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, [], ?thegame["active_game"]]

Step 1469:
  program counter:   1652
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["active_game"], []); insert first value into the second; push result ([?thegame["active_game"]])
  source code:       wait(?g->active_game, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame["active_game"] ]]

Step 1470:
  program counter:   1653
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->active_game, ?g->lock)
                                            ^
  stack:             [{:}, [ ?thegame["active_game"] ], ?thegame]

Step 1471:
  program counter:   1654
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->active_game, ?g->lock)
                                               ^^^^
  stack:             [{:}, [ ?thegame["active_game"] ], ?thegame, "lock"]

Step 1472:
  program counter:   1655
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->active_game, ?g->lock)
                                            ^^^^^^^
  stack:             [{:}, [ ?thegame["active_game"] ], ?thegame["lock"]]

Step 1473:
  program counter:   1656
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["active_game"]]); insert first value into the second; push result ([?thegame["active_game"], ?thegame["lock"]])
  source code:       wait(?g->active_game, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame["active_game"], ?thegame["lock"] ]]

Step 1474:
  program counter:   1657
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["active_game"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->active_game, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
  stack:             [{:}, [], 26514, [ ?thegame["active_game"], ?thegame["lock"] ]]

Step 1475:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["active_game"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 26514, { "g": ?thegame }]

Step 1476:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 26514, { "g": ?thegame }, 0]

Step 1477:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 26514, { "g": ?thegame }]

Step 1478:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["active_game"], lk: ?thegame["lock"] }

Step 1479:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 26514, { "g": ?thegame }, []]

Step 1480:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1481:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 1482:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 26514, { "g": ?thegame }]

Step 1483:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])

Step 1484:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605)]

Step 1485:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605), []]

Step 1486:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605), [], ?thegame["active_game"]]

Step 1487:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605), [], {:}]

Step 1488:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605), [ {:} ]]

Step 1489:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1490:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1491:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1492:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }]))
  stack:             [{:}, [], 26514, { "g": ?thegame }, [], 16242, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1493:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
  stack:             [{:}, [], 26514, { "g": ?thegame }, 0]

Step 1494:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["active_game"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 26514, { "g": ?thegame }]

Step 1495:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"]]

Step 1496:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696)]

Step 1497:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696), []]

Step 1498:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696), [], ?thegame["active_game"]]

Step 1499:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696), [], {:}]

Step 1500:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696), [ {:} ]]

Step 1501:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1502:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], PC(696), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1503:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])], PC(696)); push result (?PC(696)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], ?PC(696)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1504:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"]) --> add({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }]))
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], [], 16418, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1505:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["active_game"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 1506:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["active_game"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=1,sp=4,STACK[{:},[],26514,{ "g": ?thegame }]): 1 }) and address (?thegame["active_game"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 26514, { "g": ?thegame }]

Step 1507:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["lock"]]

Step 1508:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 26514, { "g": ?thegame }, ?thegame["lock"], False]

Step 1509:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 26514, { "g": ?thegame }]

Step 1510:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T5: player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
method variables:
  c: ?thegame["players"]
  cnt: 0
  ctx: CONTEXT({'type': 'pc', 'value': '1004'})
  lk: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31634', '{ "self": 4 }', '[]', '29586', '{ "g": ?thegame, "id": 4 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 runnable player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=1032 runnable player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T6: pc=1032 runnable player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1032 runnable player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] }
state id: 2469704
================================================

Step 1511:
  program counter:   1032
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=53 column=20
  end statement:     line=55 column=6
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])

Step 1512:
  program counter:   1033
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):

Step 1513:
  program counter:   1034
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                           ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 1514:
  program counter:   1035
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                          ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, False]

Step 1515:
  program counter:   1036
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, True]

Step 1516:
  program counter:   1037
  hvm code:          JumpCond False 1050
  explanation:       pop value (True), compare to False, and jump to 1050 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 1517:
  program counter:   1038
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605)]

Step 1518:
  program counter:   1039
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), []]

Step 1519:
  program counter:   1040
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                      ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [], ?thegame["players"]]

Step 1520:
  program counter:   1041
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [], {:}]

Step 1521:
  program counter:   1042
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [ {:} ]]

Step 1522:
  program counter:   1043
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])) of variable "ctx"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                         ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1523:
  program counter:   1044
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1524:
  program counter:   1045
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1525:
  program counter:   1046
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }])]) and call method (605: "multiplicity")
  start expression:  line=53 column=40
  end expression:    line=53 column=64
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 4 },[],29586,{ "g": ?thegame, "id": 4 }]))
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, [], 16738, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1526:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, 0]

Step 1527:
  program counter:   1047
  hvm code:          LoadVar cnt
  explanation:       push value (0) of variable "cnt"
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                 ^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, 0, 0]

Step 1528:
  program counter:   1048
  hvm code:          2-ary <=
  explanation:       pop 2 values (0, 0); check if second value is less than or equal to the first; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, True]

Step 1529:
  program counter:   1049
  hvm code:          Jump 1051
  explanation:       set program counter to 1051
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                               ^^^

Step 1530:
  program counter:   1051
  hvm code:          JumpCond False 1056
  explanation:       pop value (True), compare to False, and jump to 1056 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 1531:
  program counter:   1052
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                    ^
  method variables:  { cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1532:
  program counter:   1053
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1533:
  program counter:   1054
  hvm code:          DelVar ctx
  explanation:       delete method variable ctx
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { lk: ?thegame["lock"] }

Step 1534:
  program counter:   1055
  hvm code:          Jump 1059
  explanation:       set program counter to 1059
  start expression:  line=53 column=72
  end expression:    line=53 column=72

Step 1535:
  program counter:   1059
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1536:
  program counter:   1060
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=54 column=13
  end statement:     line=54 column=22
  source code:       !lk = True
                      ^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 1537:
  program counter:   1061
  hvm code:          DelVar lk
  explanation:       delete method variable lk
  start expression:  line=54 column=14
  end expression:    line=54 column=15
  method variables:  { }

Step 1538:
  program counter:   1062
  hvm code:          Push True
  explanation:       push constant True
  source code:       !lk = True
                           ^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }, ?thegame["lock"], True]

Step 1539:
  program counter:   1063
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !lk = True
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29586, { "g": ?thegame, "id": 4 }]

Step 1540:
  program counter:   1064
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1541:
  program counter:   1065
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, None]

Step 1542:
  program counter:   1850
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1543:
  program counter:   1851
  hvm code:          Jump 1800
  explanation:       set program counter to 1800
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1544:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 1545:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "team1"]

Step 1546:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["team1"]]

Step 1547:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, { 1, 5, 6 }]

Step 1548:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 3]

Step 1549:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 4 }, 3, ?thegame]

Step 1550:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 3, ?thegame, "team2"]

Step 1551:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 3, ?thegame["team2"]]

Step 1552:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, 3, { 2, 3, 4 }]

Step 1553:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3, 4 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 3, 3]

Step 1554:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (3, 3); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, False]

Step 1555:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1556:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 1557:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "team1"]

Step 1558:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["team1"]]

Step 1559:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, { 1, 5, 6 }]

Step 1560:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 3]

Step 1561:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 4 }, 3, 0]

Step 1562:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 3); check if both values are the same; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, False]

Step 1563:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1564:
  program counter:   1820
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^
  stack:             [{:}, [], 31634, { "self": 4 }, 4]

Step 1565:
  program counter:   1821
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^
  stack:             [{:}, [], 31634, { "self": 4 }, 4, ?thegame]

Step 1566:
  program counter:   1822
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                      ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 4, ?thegame, "team1"]

Step 1567:
  program counter:   1823
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 4, ?thegame["team1"]]

Step 1568:
  program counter:   1824
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=83
  end expression:    line=46 column=90
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, 4, { 1, 5, 6 }]

Step 1569:
  program counter:   1825
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 5, 6 }, 4); check if the second value is a member of the first; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, False]

Step 1570:
  program counter:   1826
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  start expression:  line=46 column=73
  end expression:    line=46 column=90
  stack:             [{:}, [], 31634, { "self": 4 }, True]

Step 1571:
  program counter:   1827
  hvm code:          JumpCond False 1836
  explanation:       pop value (True), compare to False, and jump to 1836 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1572:
  program counter:   1828
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                  ^^
  stack:             [{:}, [], 31634, { "self": 4 }, 4]

Step 1573:
  program counter:   1829
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                            ^
  stack:             [{:}, [], 31634, { "self": 4 }, 4, ?thegame]

Step 1574:
  program counter:   1830
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                               ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 4, ?thegame, "team2"]

Step 1575:
  program counter:   1831
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, 4, ?thegame["team2"]]

Step 1576:
  program counter:   1832
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=108
  end expression:    line=46 column=115
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, 4, { 2, 3, 4 }]

Step 1577:
  program counter:   1833
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3, 4 }, 4); check if the second value is a member of the first; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, True]

Step 1578:
  program counter:   1834
  hvm code:          1-ary not
  explanation:       pop a value (True); logical not; push result (False)
  start expression:  line=46 column=98
  end expression:    line=46 column=115
  stack:             [{:}, [], 31634, { "self": 4 }, False]

Step 1579:
  program counter:   1835
  hvm code:          Jump 1839
  explanation:       set program counter to 1839
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                             ^^^

Step 1580:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (False), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1581:
  program counter:   1852
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=50 column=5
  end statement:     line=50 column=32
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }

Step 1582:
  program counter:   1853
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start expression:  line=50 column=14
  end expression:    line=50 column=31
  stack:             [{:}, [], 31634, { "self": 4 }, []]

Step 1583:
  program counter:   1854
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                              ^
  stack:             [{:}, [], 31634, { "self": 4 }, [], ?thegame]

Step 1584:
  program counter:   1855
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       teams = (g->team1, g->team2)
                                 ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], ?thegame, "team1"]

Step 1585:
  program counter:   1856
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], ?thegame["team1"]]

Step 1586:
  program counter:   1857
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=50 column=14
  end expression:    line=50 column=21
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, [], { 1, 5, 6 }]

Step 1587:
  program counter:   1858
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 1, 5, 6 }, []); insert first value into the second; push result ([{ 1, 5, 6 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ { 1, 5, 6 } ]]

Step 1588:
  program counter:   1859
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                                        ^
  stack:             [{:}, [], 31634, { "self": 4 }, [ { 1, 5, 6 } ], ?thegame]

Step 1589:
  program counter:   1860
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       teams = (g->team1, g->team2)
                                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ { 1, 5, 6 } ], ?thegame, "team2"]

Step 1590:
  program counter:   1861
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       teams = (g->team1, g->team2)
                                        ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ { 1, 5, 6 } ], ?thegame["team2"]]

Step 1591:
  program counter:   1862
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=50 column=24
  end expression:    line=50 column=31
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, [ { 1, 5, 6 } ], { 2, 3, 4 }]

Step 1592:
  program counter:   1863
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, [{ 1, 5, 6 }]); insert first value into the second; push result ([{ 1, 5, 6 }, { 2, 3, 4 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1593:
  program counter:   1864
  hvm code:          StoreVar teams
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"teams\"
  source code:       teams = (g->team1, g->team2)
                     ^^^^^^^
  method variables:  { g: ?thegame, teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1594:
  program counter:   1865
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame]

Step 1595:
  program counter:   1866
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=52 column=14
  end expression:    line=52 column=14
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }

Step 1596:
  program counter:   1867
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame, "lock"]

Step 1597:
  program counter:   1868
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, ?thegame["lock"]]

Step 1598:
  program counter:   1869
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> release(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, ?thegame["lock"]]

Step 1599:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1600:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(4) --> game_join(?thegame, 4) --> release(?thegame["lock"])

Step 1601:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1602:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1603:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1604:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, True]

Step 1605:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1606:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1607:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1608:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1609:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 1610:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"], False]

Step 1611:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 4 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1612:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1613:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  call trace:        player(4) --> game_join(?thegame, 4)
  stack:             [{:}, [], 31634, { "self": 4 }, None]

Step 1614:
  program counter:   1870
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 4 }]

Step 1615:
  program counter:   1871
  hvm code:          ReturnOp(teams)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 4 }
  call trace:        player(4)
  stack:             [{:}, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1616:
  program counter:   1978
  hvm code:          StoreVar (team1, team2)
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"(team1, team2)\"
  module:            __main__
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 4, team1: { 1, 5, 6 }, team2: { 2, 3, 4 } }
  stack:             [{:}]

Step 1617:
  program counter:   1979
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=9
  end statement:     line=7 column=38
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1618:
  program counter:   1980
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 1619:
  program counter:   1981
  hvm code:          LoadVar self
  explanation:       push value (4) of variable "self"
  source code:       assert self in (team1 | team2)
                            ^^^^
  stack:             [{:}, 4]

Step 1620:
  program counter:   1982
  hvm code:          LoadVar team1
  explanation:       push value ({ 1, 5, 6 }) of variable "team1"
  source code:       assert self in (team1 | team2)
                                     ^^^^^
  stack:             [{:}, 4, { 1, 5, 6 }]

Step 1621:
  program counter:   1983
  hvm code:          DelVar team1
  explanation:       delete method variable team1
  start expression:  line=7 column=25
  end expression:    line=7 column=29
  method variables:  { self: 4, team2: { 2, 3, 4 } }

Step 1622:
  program counter:   1984
  hvm code:          LoadVar team2
  explanation:       push value ({ 2, 3, 4 }) of variable "team2"
  source code:       assert self in (team1 | team2)
                                             ^^^^^
  stack:             [{:}, 4, { 1, 5, 6 }, { 2, 3, 4 }]

Step 1623:
  program counter:   1985
  hvm code:          DelVar team2
  explanation:       delete method variable team2
  start expression:  line=7 column=33
  end expression:    line=7 column=37
  method variables:  { self: 4 }

Step 1624:
  program counter:   1986
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 2, 3, 4 }, { 1, 5, 6 }); union; push result ({ 1, 2, 3, 4, 5, 6 })
  source code:       assert self in (team1 | team2)
                                     ^^^^^^^^^^^^^
  stack:             [{:}, 4, { 1, 2, 3, 4, 5, 6 }]

Step 1625:
  program counter:   1987
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 2, 3, 4, 5, 6 }, 4); check if the second value is a member of the first; push result (True)
  source code:       assert self in (team1 | team2)
                            ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1626:
  program counter:   1988
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert self in (team1 | team2)
                     ^^^^^^
  stack:             [{:}]

Step 1627:
  program counter:   1989
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1628:
  program counter:   1990
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 1629:
  program counter:   1991
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 1630:
  program counter:   1992
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       game_leave(?thegame, self)
                                 ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 1631:
  program counter:   1993
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 1632:
  program counter:   1994
  hvm code:          LoadVar self
  explanation:       push value (4) of variable "self"
  source code:       game_leave(?thegame, self)
                                          ^^^^
  stack:             [{:}, [ ?thegame ], 4]

Step 1633:
  program counter:   1995
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=9 column=26
  end expression:    line=9 column=29
  method variables:  { }

Step 1634:
  program counter:   1996
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (4, [?thegame]); insert first value into the second; push result ([?thegame, 4])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 4 ]]

Step 1635:
  program counter:   1997
  hvm code:          Apply PC(1874)
  explanation:       pop an argument ([?thegame, 4]) and call method (1874: "game_leave")
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, [ ?thegame, 4 ]]

Step 1636:
  program counter:   1874
  hvm code:          Frame game_leave(g, id)
  explanation:       pop argument ([?thegame, 4]), assign to (g, id), and run method "game_leave"
  module:            game
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  stack:             [{:}, [], 31954, {:}]

Step 1637:
  program counter:   1875
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 1638:
  program counter:   1876
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 1639:
  program counter:   1877
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 1640:
  program counter:   1878
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 30050, ?thegame["lock"]]

Step 1641:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }]

================================================
Running thread T6: player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
method variables:
  c: ?thegame["players"]
  cnt: 0
  ctx: CONTEXT({'type': 'pc', 'value': '1004'})
  lk: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31634', '{ "self": 5 }', '[]', '29586', '{ "g": ?thegame, "id": 5 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 runnable player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=1032 runnable player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=955 runnable player(4) --> game_leave(?thegame, 4) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=1032 runnable player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] }
state id: 3446930
================================================

Step 1642:
  program counter:   1032
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=53 column=20
  end statement:     line=55 column=6
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])

Step 1643:
  program counter:   1033
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):

Step 1644:
  program counter:   1034
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                           ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 1645:
  program counter:   1035
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                          ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, False]

Step 1646:
  program counter:   1036
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, True]

Step 1647:
  program counter:   1037
  hvm code:          JumpCond False 1050
  explanation:       pop value (True), compare to False, and jump to 1050 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 1648:
  program counter:   1038
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605)]

Step 1649:
  program counter:   1039
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), []]

Step 1650:
  program counter:   1040
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                      ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [], ?thegame["players"]]

Step 1651:
  program counter:   1041
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [], {:}]

Step 1652:
  program counter:   1042
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [ {:} ]]

Step 1653:
  program counter:   1043
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])) of variable "ctx"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                         ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1654:
  program counter:   1044
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1655:
  program counter:   1045
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1656:
  program counter:   1046
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }])]) and call method (605: "multiplicity")
  start expression:  line=53 column=40
  end expression:    line=53 column=64
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 5 },[],29586,{ "g": ?thegame, "id": 5 }]))
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, [], 16738, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1657:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, 0]

Step 1658:
  program counter:   1047
  hvm code:          LoadVar cnt
  explanation:       push value (0) of variable "cnt"
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                 ^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, 0, 0]

Step 1659:
  program counter:   1048
  hvm code:          2-ary <=
  explanation:       pop 2 values (0, 0); check if second value is less than or equal to the first; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, True]

Step 1660:
  program counter:   1049
  hvm code:          Jump 1051
  explanation:       set program counter to 1051
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                               ^^^

Step 1661:
  program counter:   1051
  hvm code:          JumpCond False 1056
  explanation:       pop value (True), compare to False, and jump to 1056 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 1662:
  program counter:   1052
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                    ^
  method variables:  { cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1663:
  program counter:   1053
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1664:
  program counter:   1054
  hvm code:          DelVar ctx
  explanation:       delete method variable ctx
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { lk: ?thegame["lock"] }

Step 1665:
  program counter:   1055
  hvm code:          Jump 1059
  explanation:       set program counter to 1059
  start expression:  line=53 column=72
  end expression:    line=53 column=72

Step 1666:
  program counter:   1059
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1667:
  program counter:   1060
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=54 column=13
  end statement:     line=54 column=22
  source code:       !lk = True
                      ^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 1668:
  program counter:   1061
  hvm code:          DelVar lk
  explanation:       delete method variable lk
  start expression:  line=54 column=14
  end expression:    line=54 column=15
  method variables:  { }

Step 1669:
  program counter:   1062
  hvm code:          Push True
  explanation:       push constant True
  source code:       !lk = True
                           ^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }, ?thegame["lock"], True]

Step 1670:
  program counter:   1063
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !lk = True
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29586, { "g": ?thegame, "id": 5 }]

Step 1671:
  program counter:   1064
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1672:
  program counter:   1065
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, None]

Step 1673:
  program counter:   1850
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1674:
  program counter:   1851
  hvm code:          Jump 1800
  explanation:       set program counter to 1800
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1675:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 1676:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "team1"]

Step 1677:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["team1"]]

Step 1678:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, { 1, 5, 6 }]

Step 1679:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 3]

Step 1680:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 5 }, 3, ?thegame]

Step 1681:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 3, ?thegame, "team2"]

Step 1682:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 3, ?thegame["team2"]]

Step 1683:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, 3, { 2, 3, 4 }]

Step 1684:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3, 4 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 3, 3]

Step 1685:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (3, 3); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, False]

Step 1686:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1687:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 1688:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "team1"]

Step 1689:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["team1"]]

Step 1690:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, { 1, 5, 6 }]

Step 1691:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 3]

Step 1692:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 5 }, 3, 0]

Step 1693:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 3); check if both values are the same; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, False]

Step 1694:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1695:
  program counter:   1820
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^
  stack:             [{:}, [], 31634, { "self": 5 }, 5]

Step 1696:
  program counter:   1821
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^
  stack:             [{:}, [], 31634, { "self": 5 }, 5, ?thegame]

Step 1697:
  program counter:   1822
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                      ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 5, ?thegame, "team1"]

Step 1698:
  program counter:   1823
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, 5, ?thegame["team1"]]

Step 1699:
  program counter:   1824
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=83
  end expression:    line=46 column=90
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, 5, { 1, 5, 6 }]

Step 1700:
  program counter:   1825
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 5, 6 }, 5); check if the second value is a member of the first; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, True]

Step 1701:
  program counter:   1826
  hvm code:          1-ary not
  explanation:       pop a value (True); logical not; push result (False)
  start expression:  line=46 column=73
  end expression:    line=46 column=90
  stack:             [{:}, [], 31634, { "self": 5 }, False]

Step 1702:
  program counter:   1827
  hvm code:          JumpCond False 1836
  explanation:       pop value (False), compare to False, and jump to 1836 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1703:
  program counter:   1836
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=46 column=72
  end expression:    line=46 column=116
  stack:             [{:}, [], 31634, { "self": 5 }, False]

Step 1704:
  program counter:   1837
  hvm code:          Jump 1839
  explanation:       set program counter to 1839
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                            ^^

Step 1705:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (False), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1706:
  program counter:   1852
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=50 column=5
  end statement:     line=50 column=32
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }

Step 1707:
  program counter:   1853
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start expression:  line=50 column=14
  end expression:    line=50 column=31
  stack:             [{:}, [], 31634, { "self": 5 }, []]

Step 1708:
  program counter:   1854
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                              ^
  stack:             [{:}, [], 31634, { "self": 5 }, [], ?thegame]

Step 1709:
  program counter:   1855
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       teams = (g->team1, g->team2)
                                 ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], ?thegame, "team1"]

Step 1710:
  program counter:   1856
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], ?thegame["team1"]]

Step 1711:
  program counter:   1857
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=50 column=14
  end expression:    line=50 column=21
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, [], { 1, 5, 6 }]

Step 1712:
  program counter:   1858
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 1, 5, 6 }, []); insert first value into the second; push result ([{ 1, 5, 6 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ { 1, 5, 6 } ]]

Step 1713:
  program counter:   1859
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                                        ^
  stack:             [{:}, [], 31634, { "self": 5 }, [ { 1, 5, 6 } ], ?thegame]

Step 1714:
  program counter:   1860
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       teams = (g->team1, g->team2)
                                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ { 1, 5, 6 } ], ?thegame, "team2"]

Step 1715:
  program counter:   1861
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       teams = (g->team1, g->team2)
                                        ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ { 1, 5, 6 } ], ?thegame["team2"]]

Step 1716:
  program counter:   1862
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=50 column=24
  end expression:    line=50 column=31
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, [ { 1, 5, 6 } ], { 2, 3, 4 }]

Step 1717:
  program counter:   1863
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, [{ 1, 5, 6 }]); insert first value into the second; push result ([{ 1, 5, 6 }, { 2, 3, 4 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1718:
  program counter:   1864
  hvm code:          StoreVar teams
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"teams\"
  source code:       teams = (g->team1, g->team2)
                     ^^^^^^^
  method variables:  { g: ?thegame, teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1719:
  program counter:   1865
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame]

Step 1720:
  program counter:   1866
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=52 column=14
  end expression:    line=52 column=14
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }

Step 1721:
  program counter:   1867
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame, "lock"]

Step 1722:
  program counter:   1868
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, ?thegame["lock"]]

Step 1723:
  program counter:   1869
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> release(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, ?thegame["lock"]]

Step 1724:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1725:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> release(?thegame["lock"])

Step 1726:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1727:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1728:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1729:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, True]

Step 1730:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1731:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1732:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1733:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1734:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 1735:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"], False]

Step 1736:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 5 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1737:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1738:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 31634, { "self": 5 }, None]

Step 1739:
  program counter:   1870
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 5 }]

Step 1740:
  program counter:   1871
  hvm code:          ReturnOp(teams)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 5 }
  call trace:        player(5)
  stack:             [{:}, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1741:
  program counter:   1978
  hvm code:          StoreVar (team1, team2)
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"(team1, team2)\"
  module:            __main__
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 5, team1: { 1, 5, 6 }, team2: { 2, 3, 4 } }
  stack:             [{:}]

Step 1742:
  program counter:   1979
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=9
  end statement:     line=7 column=38
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1743:
  program counter:   1980
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 1744:
  program counter:   1981
  hvm code:          LoadVar self
  explanation:       push value (5) of variable "self"
  source code:       assert self in (team1 | team2)
                            ^^^^
  stack:             [{:}, 5]

Step 1745:
  program counter:   1982
  hvm code:          LoadVar team1
  explanation:       push value ({ 1, 5, 6 }) of variable "team1"
  source code:       assert self in (team1 | team2)
                                     ^^^^^
  stack:             [{:}, 5, { 1, 5, 6 }]

Step 1746:
  program counter:   1983
  hvm code:          DelVar team1
  explanation:       delete method variable team1
  start expression:  line=7 column=25
  end expression:    line=7 column=29
  method variables:  { self: 5, team2: { 2, 3, 4 } }

Step 1747:
  program counter:   1984
  hvm code:          LoadVar team2
  explanation:       push value ({ 2, 3, 4 }) of variable "team2"
  source code:       assert self in (team1 | team2)
                                             ^^^^^
  stack:             [{:}, 5, { 1, 5, 6 }, { 2, 3, 4 }]

Step 1748:
  program counter:   1985
  hvm code:          DelVar team2
  explanation:       delete method variable team2
  start expression:  line=7 column=33
  end expression:    line=7 column=37
  method variables:  { self: 5 }

Step 1749:
  program counter:   1986
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 2, 3, 4 }, { 1, 5, 6 }); union; push result ({ 1, 2, 3, 4, 5, 6 })
  source code:       assert self in (team1 | team2)
                                     ^^^^^^^^^^^^^
  stack:             [{:}, 5, { 1, 2, 3, 4, 5, 6 }]

Step 1750:
  program counter:   1987
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 2, 3, 4, 5, 6 }, 5); check if the second value is a member of the first; push result (True)
  source code:       assert self in (team1 | team2)
                            ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1751:
  program counter:   1988
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert self in (team1 | team2)
                     ^^^^^^
  stack:             [{:}]

Step 1752:
  program counter:   1989
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1753:
  program counter:   1990
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 1754:
  program counter:   1991
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 1755:
  program counter:   1992
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       game_leave(?thegame, self)
                                 ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 1756:
  program counter:   1993
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 1757:
  program counter:   1994
  hvm code:          LoadVar self
  explanation:       push value (5) of variable "self"
  source code:       game_leave(?thegame, self)
                                          ^^^^
  stack:             [{:}, [ ?thegame ], 5]

Step 1758:
  program counter:   1995
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=9 column=26
  end expression:    line=9 column=29
  method variables:  { }

Step 1759:
  program counter:   1996
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (5, [?thegame]); insert first value into the second; push result ([?thegame, 5])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 5 ]]

Step 1760:
  program counter:   1997
  hvm code:          Apply PC(1874)
  explanation:       pop an argument ([?thegame, 5]) and call method (1874: "game_leave")
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_leave(?thegame, 5)
  stack:             [{:}, [], 31954, [ ?thegame, 5 ]]

Step 1761:
  program counter:   1874
  hvm code:          Frame game_leave(g, id)
  explanation:       pop argument ([?thegame, 5]), assign to (g, id), and run method "game_leave"
  module:            game
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  stack:             [{:}, [], 31954, {:}]

Step 1762:
  program counter:   1875
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 1763:
  program counter:   1876
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 1764:
  program counter:   1877
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 1765:
  program counter:   1878
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 30050, ?thegame["lock"]]

Step 1766:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }]

================================================
Running thread T4: player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
method variables:
  c: ?thegame["players"]
  cnt: 0
  ctx: CONTEXT({'type': 'pc', 'value': '1004'})
  lk: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31634', '{ "self": 3 }', '[]', '29586', '{ "g": ?thegame, "id": 3 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 runnable player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=955 runnable player(4) --> game_leave(?thegame, 4) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=1032 runnable player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] }
state id: 4414549
================================================

Step 1767:
  program counter:   1032
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=53 column=20
  end statement:     line=55 column=6
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])

Step 1768:
  program counter:   1033
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):

Step 1769:
  program counter:   1034
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                           ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 1770:
  program counter:   1035
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                          ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, False]

Step 1771:
  program counter:   1036
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, True]

Step 1772:
  program counter:   1037
  hvm code:          JumpCond False 1050
  explanation:       pop value (True), compare to False, and jump to 1050 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 1773:
  program counter:   1038
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605)]

Step 1774:
  program counter:   1039
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), []]

Step 1775:
  program counter:   1040
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                      ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [], ?thegame["players"]]

Step 1776:
  program counter:   1041
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [], {:}]

Step 1777:
  program counter:   1042
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [ {:} ]]

Step 1778:
  program counter:   1043
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])) of variable "ctx"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                         ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1779:
  program counter:   1044
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1780:
  program counter:   1045
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1781:
  program counter:   1046
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }])]) and call method (605: "multiplicity")
  start expression:  line=53 column=40
  end expression:    line=53 column=64
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 3 },[],29586,{ "g": ?thegame, "id": 3 }]))
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, [], 16738, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1782:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, 0]

Step 1783:
  program counter:   1047
  hvm code:          LoadVar cnt
  explanation:       push value (0) of variable "cnt"
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                 ^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, 0, 0]

Step 1784:
  program counter:   1048
  hvm code:          2-ary <=
  explanation:       pop 2 values (0, 0); check if second value is less than or equal to the first; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, True]

Step 1785:
  program counter:   1049
  hvm code:          Jump 1051
  explanation:       set program counter to 1051
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                               ^^^

Step 1786:
  program counter:   1051
  hvm code:          JumpCond False 1056
  explanation:       pop value (True), compare to False, and jump to 1056 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 1787:
  program counter:   1052
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                    ^
  method variables:  { cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1788:
  program counter:   1053
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1789:
  program counter:   1054
  hvm code:          DelVar ctx
  explanation:       delete method variable ctx
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { lk: ?thegame["lock"] }

Step 1790:
  program counter:   1055
  hvm code:          Jump 1059
  explanation:       set program counter to 1059
  start expression:  line=53 column=72
  end expression:    line=53 column=72

Step 1791:
  program counter:   1059
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1792:
  program counter:   1060
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=54 column=13
  end statement:     line=54 column=22
  source code:       !lk = True
                      ^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 1793:
  program counter:   1061
  hvm code:          DelVar lk
  explanation:       delete method variable lk
  start expression:  line=54 column=14
  end expression:    line=54 column=15
  method variables:  { }

Step 1794:
  program counter:   1062
  hvm code:          Push True
  explanation:       push constant True
  source code:       !lk = True
                           ^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }, ?thegame["lock"], True]

Step 1795:
  program counter:   1063
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !lk = True
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29586, { "g": ?thegame, "id": 3 }]

Step 1796:
  program counter:   1064
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1797:
  program counter:   1065
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 3 }
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, None]

Step 1798:
  program counter:   1850
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1799:
  program counter:   1851
  hvm code:          Jump 1800
  explanation:       set program counter to 1800
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1800:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 1801:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "team1"]

Step 1802:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["team1"]]

Step 1803:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, { 1, 5, 6 }]

Step 1804:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3]

Step 1805:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame]

Step 1806:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame, "team2"]

Step 1807:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame["team2"]]

Step 1808:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, 3, { 2, 3, 4 }]

Step 1809:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3, 4 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, 3]

Step 1810:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (3, 3); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, False]

Step 1811:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1812:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 1813:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "team1"]

Step 1814:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["team1"]]

Step 1815:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, { 1, 5, 6 }]

Step 1816:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3]

Step 1817:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, 0]

Step 1818:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 3); check if both values are the same; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, False]

Step 1819:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1820:
  program counter:   1820
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3]

Step 1821:
  program counter:   1821
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame]

Step 1822:
  program counter:   1822
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                      ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame, "team1"]

Step 1823:
  program counter:   1823
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame["team1"]]

Step 1824:
  program counter:   1824
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=83
  end expression:    line=46 column=90
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, 3, { 1, 5, 6 }]

Step 1825:
  program counter:   1825
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 5, 6 }, 3); check if the second value is a member of the first; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, False]

Step 1826:
  program counter:   1826
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  start expression:  line=46 column=73
  end expression:    line=46 column=90
  stack:             [{:}, [], 31634, { "self": 3 }, True]

Step 1827:
  program counter:   1827
  hvm code:          JumpCond False 1836
  explanation:       pop value (True), compare to False, and jump to 1836 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1828:
  program counter:   1828
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                  ^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3]

Step 1829:
  program counter:   1829
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                            ^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame]

Step 1830:
  program counter:   1830
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                               ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame, "team2"]

Step 1831:
  program counter:   1831
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, 3, ?thegame["team2"]]

Step 1832:
  program counter:   1832
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=108
  end expression:    line=46 column=115
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, 3, { 2, 3, 4 }]

Step 1833:
  program counter:   1833
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3, 4 }, 3); check if the second value is a member of the first; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, True]

Step 1834:
  program counter:   1834
  hvm code:          1-ary not
  explanation:       pop a value (True); logical not; push result (False)
  start expression:  line=46 column=98
  end expression:    line=46 column=115
  stack:             [{:}, [], 31634, { "self": 3 }, False]

Step 1835:
  program counter:   1835
  hvm code:          Jump 1839
  explanation:       set program counter to 1839
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                             ^^^

Step 1836:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (False), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1837:
  program counter:   1852
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=50 column=5
  end statement:     line=50 column=32
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }

Step 1838:
  program counter:   1853
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start expression:  line=50 column=14
  end expression:    line=50 column=31
  stack:             [{:}, [], 31634, { "self": 3 }, []]

Step 1839:
  program counter:   1854
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                              ^
  stack:             [{:}, [], 31634, { "self": 3 }, [], ?thegame]

Step 1840:
  program counter:   1855
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       teams = (g->team1, g->team2)
                                 ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], ?thegame, "team1"]

Step 1841:
  program counter:   1856
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], ?thegame["team1"]]

Step 1842:
  program counter:   1857
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=50 column=14
  end expression:    line=50 column=21
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, [], { 1, 5, 6 }]

Step 1843:
  program counter:   1858
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 1, 5, 6 }, []); insert first value into the second; push result ([{ 1, 5, 6 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ { 1, 5, 6 } ]]

Step 1844:
  program counter:   1859
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                                        ^
  stack:             [{:}, [], 31634, { "self": 3 }, [ { 1, 5, 6 } ], ?thegame]

Step 1845:
  program counter:   1860
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       teams = (g->team1, g->team2)
                                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ { 1, 5, 6 } ], ?thegame, "team2"]

Step 1846:
  program counter:   1861
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       teams = (g->team1, g->team2)
                                        ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ { 1, 5, 6 } ], ?thegame["team2"]]

Step 1847:
  program counter:   1862
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=50 column=24
  end expression:    line=50 column=31
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, [ { 1, 5, 6 } ], { 2, 3, 4 }]

Step 1848:
  program counter:   1863
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, [{ 1, 5, 6 }]); insert first value into the second; push result ([{ 1, 5, 6 }, { 2, 3, 4 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1849:
  program counter:   1864
  hvm code:          StoreVar teams
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"teams\"
  source code:       teams = (g->team1, g->team2)
                     ^^^^^^^
  method variables:  { g: ?thegame, teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1850:
  program counter:   1865
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame]

Step 1851:
  program counter:   1866
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=52 column=14
  end expression:    line=52 column=14
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }

Step 1852:
  program counter:   1867
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame, "lock"]

Step 1853:
  program counter:   1868
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, ?thegame["lock"]]

Step 1854:
  program counter:   1869
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> release(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, ?thegame["lock"]]

Step 1855:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1856:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(3) --> game_join(?thegame, 3) --> release(?thegame["lock"])

Step 1857:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1858:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1859:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1860:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, True]

Step 1861:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1862:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1863:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1864:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1865:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 1866:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"], False]

Step 1867:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 3 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1868:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1869:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  call trace:        player(3) --> game_join(?thegame, 3)
  stack:             [{:}, [], 31634, { "self": 3 }, None]

Step 1870:
  program counter:   1870
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 3 }]

Step 1871:
  program counter:   1871
  hvm code:          ReturnOp(teams)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 3 }
  call trace:        player(3)
  stack:             [{:}, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1872:
  program counter:   1978
  hvm code:          StoreVar (team1, team2)
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"(team1, team2)\"
  module:            __main__
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 3, team1: { 1, 5, 6 }, team2: { 2, 3, 4 } }
  stack:             [{:}]

Step 1873:
  program counter:   1979
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=9
  end statement:     line=7 column=38
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1874:
  program counter:   1980
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 1875:
  program counter:   1981
  hvm code:          LoadVar self
  explanation:       push value (3) of variable "self"
  source code:       assert self in (team1 | team2)
                            ^^^^
  stack:             [{:}, 3]

Step 1876:
  program counter:   1982
  hvm code:          LoadVar team1
  explanation:       push value ({ 1, 5, 6 }) of variable "team1"
  source code:       assert self in (team1 | team2)
                                     ^^^^^
  stack:             [{:}, 3, { 1, 5, 6 }]

Step 1877:
  program counter:   1983
  hvm code:          DelVar team1
  explanation:       delete method variable team1
  start expression:  line=7 column=25
  end expression:    line=7 column=29
  method variables:  { self: 3, team2: { 2, 3, 4 } }

Step 1878:
  program counter:   1984
  hvm code:          LoadVar team2
  explanation:       push value ({ 2, 3, 4 }) of variable "team2"
  source code:       assert self in (team1 | team2)
                                             ^^^^^
  stack:             [{:}, 3, { 1, 5, 6 }, { 2, 3, 4 }]

Step 1879:
  program counter:   1985
  hvm code:          DelVar team2
  explanation:       delete method variable team2
  start expression:  line=7 column=33
  end expression:    line=7 column=37
  method variables:  { self: 3 }

Step 1880:
  program counter:   1986
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 2, 3, 4 }, { 1, 5, 6 }); union; push result ({ 1, 2, 3, 4, 5, 6 })
  source code:       assert self in (team1 | team2)
                                     ^^^^^^^^^^^^^
  stack:             [{:}, 3, { 1, 2, 3, 4, 5, 6 }]

Step 1881:
  program counter:   1987
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 2, 3, 4, 5, 6 }, 3); check if the second value is a member of the first; push result (True)
  source code:       assert self in (team1 | team2)
                            ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1882:
  program counter:   1988
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert self in (team1 | team2)
                     ^^^^^^
  stack:             [{:}]

Step 1883:
  program counter:   1989
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1884:
  program counter:   1990
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 1885:
  program counter:   1991
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 1886:
  program counter:   1992
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       game_leave(?thegame, self)
                                 ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 1887:
  program counter:   1993
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 1888:
  program counter:   1994
  hvm code:          LoadVar self
  explanation:       push value (3) of variable "self"
  source code:       game_leave(?thegame, self)
                                          ^^^^
  stack:             [{:}, [ ?thegame ], 3]

Step 1889:
  program counter:   1995
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=9 column=26
  end expression:    line=9 column=29
  method variables:  { }

Step 1890:
  program counter:   1996
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (3, [?thegame]); insert first value into the second; push result ([?thegame, 3])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 3 ]]

Step 1891:
  program counter:   1997
  hvm code:          Apply PC(1874)
  explanation:       pop an argument ([?thegame, 3]) and call method (1874: "game_leave")
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, [ ?thegame, 3 ]]

Step 1892:
  program counter:   1874
  hvm code:          Frame game_leave(g, id)
  explanation:       pop argument ([?thegame, 3]), assign to (g, id), and run method "game_leave"
  module:            game
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 3 }
  stack:             [{:}, [], 31954, {:}]

Step 1893:
  program counter:   1875
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 1894:
  program counter:   1876
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 1895:
  program counter:   1877
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 1896:
  program counter:   1878
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_leave(?thegame, 3) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 30050, ?thegame["lock"]]

Step 1897:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }]

================================================
Running thread T7: player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
method variables:
  c: ?thegame["players"]
  cnt: 0
  ctx: CONTEXT({'type': 'pc', 'value': '1004'})
  lk: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31634', '{ "self": 6 }', '[]', '29586', '{ "g": ?thegame, "id": 6 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 runnable player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=955 runnable player(3) --> game_leave(?thegame, 3) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T5: pc=955 runnable player(4) --> game_leave(?thegame, 4) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] }
state id: 5277790
================================================

Step 1898:
  program counter:   1032
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=53 column=20
  end statement:     line=55 column=6
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])

Step 1899:
  program counter:   1033
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):

Step 1900:
  program counter:   1034
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                           ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 1901:
  program counter:   1035
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                          ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, False]

Step 1902:
  program counter:   1036
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, True]

Step 1903:
  program counter:   1037
  hvm code:          JumpCond False 1050
  explanation:       pop value (True), compare to False, and jump to 1050 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 1904:
  program counter:   1038
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605)]

Step 1905:
  program counter:   1039
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), []]

Step 1906:
  program counter:   1040
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                      ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [], ?thegame["players"]]

Step 1907:
  program counter:   1041
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [], {:}]

Step 1908:
  program counter:   1042
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [ {:} ]]

Step 1909:
  program counter:   1043
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])) of variable "ctx"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                         ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 1910:
  program counter:   1044
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1911:
  program counter:   1045
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 1912:
  program counter:   1046
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }])]) and call method (605: "multiplicity")
  start expression:  line=53 column=40
  end expression:    line=53 column=64
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 6 },[],29586,{ "g": ?thegame, "id": 6 }]))
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, [], 16738, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 1913:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, 0]

Step 1914:
  program counter:   1047
  hvm code:          LoadVar cnt
  explanation:       push value (0) of variable "cnt"
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                 ^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, 0, 0]

Step 1915:
  program counter:   1048
  hvm code:          2-ary <=
  explanation:       pop 2 values (0, 0); check if second value is less than or equal to the first; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, True]

Step 1916:
  program counter:   1049
  hvm code:          Jump 1051
  explanation:       set program counter to 1051
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                               ^^^

Step 1917:
  program counter:   1051
  hvm code:          JumpCond False 1056
  explanation:       pop value (True), compare to False, and jump to 1056 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 1918:
  program counter:   1052
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                    ^
  method variables:  { cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1919:
  program counter:   1053
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 1920:
  program counter:   1054
  hvm code:          DelVar ctx
  explanation:       delete method variable ctx
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { lk: ?thegame["lock"] }

Step 1921:
  program counter:   1055
  hvm code:          Jump 1059
  explanation:       set program counter to 1059
  start expression:  line=53 column=72
  end expression:    line=53 column=72

Step 1922:
  program counter:   1059
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1923:
  program counter:   1060
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=54 column=13
  end statement:     line=54 column=22
  source code:       !lk = True
                      ^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 1924:
  program counter:   1061
  hvm code:          DelVar lk
  explanation:       delete method variable lk
  start expression:  line=54 column=14
  end expression:    line=54 column=15
  method variables:  { }

Step 1925:
  program counter:   1062
  hvm code:          Push True
  explanation:       push constant True
  source code:       !lk = True
                           ^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }, ?thegame["lock"], True]

Step 1926:
  program counter:   1063
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !lk = True
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29586, { "g": ?thegame, "id": 6 }]

Step 1927:
  program counter:   1064
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1928:
  program counter:   1065
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 6 }
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, None]

Step 1929:
  program counter:   1850
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1930:
  program counter:   1851
  hvm code:          Jump 1800
  explanation:       set program counter to 1800
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1931:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 1932:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "team1"]

Step 1933:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["team1"]]

Step 1934:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, { 1, 5, 6 }]

Step 1935:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 3]

Step 1936:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 6 }, 3, ?thegame]

Step 1937:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 3, ?thegame, "team2"]

Step 1938:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 3, ?thegame["team2"]]

Step 1939:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, 3, { 2, 3, 4 }]

Step 1940:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3, 4 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 3, 3]

Step 1941:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (3, 3); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, False]

Step 1942:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1943:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 1944:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "team1"]

Step 1945:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["team1"]]

Step 1946:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, { 1, 5, 6 }]

Step 1947:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({ 1, 5, 6 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 3]

Step 1948:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 6 }, 3, 0]

Step 1949:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 3); check if both values are the same; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, False]

Step 1950:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1951:
  program counter:   1820
  hvm code:          LoadVar id
  explanation:       push value (6) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^
  stack:             [{:}, [], 31634, { "self": 6 }, 6]

Step 1952:
  program counter:   1821
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^
  stack:             [{:}, [], 31634, { "self": 6 }, 6, ?thegame]

Step 1953:
  program counter:   1822
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                      ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 6, ?thegame, "team1"]

Step 1954:
  program counter:   1823
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, 6, ?thegame["team1"]]

Step 1955:
  program counter:   1824
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=46 column=83
  end expression:    line=46 column=90
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, 6, { 1, 5, 6 }]

Step 1956:
  program counter:   1825
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 5, 6 }, 6); check if the second value is a member of the first; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, True]

Step 1957:
  program counter:   1826
  hvm code:          1-ary not
  explanation:       pop a value (True); logical not; push result (False)
  start expression:  line=46 column=73
  end expression:    line=46 column=90
  stack:             [{:}, [], 31634, { "self": 6 }, False]

Step 1958:
  program counter:   1827
  hvm code:          JumpCond False 1836
  explanation:       pop value (False), compare to False, and jump to 1836 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1959:
  program counter:   1836
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=46 column=72
  end expression:    line=46 column=116
  stack:             [{:}, [], 31634, { "self": 6 }, False]

Step 1960:
  program counter:   1837
  hvm code:          Jump 1839
  explanation:       set program counter to 1839
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                            ^^

Step 1961:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (False), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1962:
  program counter:   1852
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=50 column=5
  end statement:     line=50 column=32
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }

Step 1963:
  program counter:   1853
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start expression:  line=50 column=14
  end expression:    line=50 column=31
  stack:             [{:}, [], 31634, { "self": 6 }, []]

Step 1964:
  program counter:   1854
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                              ^
  stack:             [{:}, [], 31634, { "self": 6 }, [], ?thegame]

Step 1965:
  program counter:   1855
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       teams = (g->team1, g->team2)
                                 ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], ?thegame, "team1"]

Step 1966:
  program counter:   1856
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], ?thegame["team1"]]

Step 1967:
  program counter:   1857
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=50 column=14
  end expression:    line=50 column=21
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, [], { 1, 5, 6 }]

Step 1968:
  program counter:   1858
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 1, 5, 6 }, []); insert first value into the second; push result ([{ 1, 5, 6 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ { 1, 5, 6 } ]]

Step 1969:
  program counter:   1859
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                                        ^
  stack:             [{:}, [], 31634, { "self": 6 }, [ { 1, 5, 6 } ], ?thegame]

Step 1970:
  program counter:   1860
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       teams = (g->team1, g->team2)
                                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ { 1, 5, 6 } ], ?thegame, "team2"]

Step 1971:
  program counter:   1861
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       teams = (g->team1, g->team2)
                                        ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ { 1, 5, 6 } ], ?thegame["team2"]]

Step 1972:
  program counter:   1862
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=50 column=24
  end expression:    line=50 column=31
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, [ { 1, 5, 6 } ], { 2, 3, 4 }]

Step 1973:
  program counter:   1863
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, [{ 1, 5, 6 }]); insert first value into the second; push result ([{ 1, 5, 6 }, { 2, 3, 4 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1974:
  program counter:   1864
  hvm code:          StoreVar teams
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"teams\"
  source code:       teams = (g->team1, g->team2)
                     ^^^^^^^
  method variables:  { g: ?thegame, teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1975:
  program counter:   1865
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame]

Step 1976:
  program counter:   1866
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=52 column=14
  end expression:    line=52 column=14
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }

Step 1977:
  program counter:   1867
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame, "lock"]

Step 1978:
  program counter:   1868
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, ?thegame["lock"]]

Step 1979:
  program counter:   1869
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> release(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, ?thegame["lock"]]

Step 1980:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1981:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(6) --> game_join(?thegame, 6) --> release(?thegame["lock"])

Step 1982:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1983:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1984:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1985:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, True]

Step 1986:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1987:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1988:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 1989:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"]]

Step 1990:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 1991:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }, ?thegame["lock"], False]

Step 1992:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 6 }, [], 29906, { "teams": [ { 1, 5, 6 }, { 2, 3, 4 } ] }]

Step 1993:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1994:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { teams: [ { 1, 5, 6 }, { 2, 3, 4 } ] }
  call trace:        player(6) --> game_join(?thegame, 6)
  stack:             [{:}, [], 31634, { "self": 6 }, None]

Step 1995:
  program counter:   1870
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 6 }]

Step 1996:
  program counter:   1871
  hvm code:          ReturnOp(teams)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 6 }
  call trace:        player(6)
  stack:             [{:}, [ { 1, 5, 6 }, { 2, 3, 4 } ]]

Step 1997:
  program counter:   1978
  hvm code:          StoreVar (team1, team2)
  explanation:       pop value ([{ 1, 5, 6 }, { 2, 3, 4 }]) and store locally in variable \"(team1, team2)\"
  module:            __main__
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 6, team1: { 1, 5, 6 }, team2: { 2, 3, 4 } }
  stack:             [{:}]

Step 1998:
  program counter:   1979
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=9
  end statement:     line=7 column=38
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1999:
  program counter:   1980
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 2000:
  program counter:   1981
  hvm code:          LoadVar self
  explanation:       push value (6) of variable "self"
  source code:       assert self in (team1 | team2)
                            ^^^^
  stack:             [{:}, 6]

Step 2001:
  program counter:   1982
  hvm code:          LoadVar team1
  explanation:       push value ({ 1, 5, 6 }) of variable "team1"
  source code:       assert self in (team1 | team2)
                                     ^^^^^
  stack:             [{:}, 6, { 1, 5, 6 }]

Step 2002:
  program counter:   1983
  hvm code:          DelVar team1
  explanation:       delete method variable team1
  start expression:  line=7 column=25
  end expression:    line=7 column=29
  method variables:  { self: 6, team2: { 2, 3, 4 } }

Step 2003:
  program counter:   1984
  hvm code:          LoadVar team2
  explanation:       push value ({ 2, 3, 4 }) of variable "team2"
  source code:       assert self in (team1 | team2)
                                             ^^^^^
  stack:             [{:}, 6, { 1, 5, 6 }, { 2, 3, 4 }]

Step 2004:
  program counter:   1985
  hvm code:          DelVar team2
  explanation:       delete method variable team2
  start expression:  line=7 column=33
  end expression:    line=7 column=37
  method variables:  { self: 6 }

Step 2005:
  program counter:   1986
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 2, 3, 4 }, { 1, 5, 6 }); union; push result ({ 1, 2, 3, 4, 5, 6 })
  source code:       assert self in (team1 | team2)
                                     ^^^^^^^^^^^^^
  stack:             [{:}, 6, { 1, 2, 3, 4, 5, 6 }]

Step 2006:
  program counter:   1987
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 2, 3, 4, 5, 6 }, 6); check if the second value is a member of the first; push result (True)
  source code:       assert self in (team1 | team2)
                            ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 2007:
  program counter:   1988
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert self in (team1 | team2)
                     ^^^^^^
  stack:             [{:}]

Step 2008:
  program counter:   1989
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2009:
  program counter:   1990
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 2010:
  program counter:   1991
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 2011:
  program counter:   1992
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       game_leave(?thegame, self)
                                 ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 2012:
  program counter:   1993
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 2013:
  program counter:   1994
  hvm code:          LoadVar self
  explanation:       push value (6) of variable "self"
  source code:       game_leave(?thegame, self)
                                          ^^^^
  stack:             [{:}, [ ?thegame ], 6]

Step 2014:
  program counter:   1995
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=9 column=26
  end expression:    line=9 column=29
  method variables:  { }

Step 2015:
  program counter:   1996
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (6, [?thegame]); insert first value into the second; push result ([?thegame, 6])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 6 ]]

Step 2016:
  program counter:   1997
  hvm code:          Apply PC(1874)
  explanation:       pop an argument ([?thegame, 6]) and call method (1874: "game_leave")
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_leave(?thegame, 6)
  stack:             [{:}, [], 31954, [ ?thegame, 6 ]]

Step 2017:
  program counter:   1874
  hvm code:          Frame game_leave(g, id)
  explanation:       pop argument ([?thegame, 6]), assign to (g, id), and run method "game_leave"
  module:            game
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 6 }
  stack:             [{:}, [], 31954, {:}]

Step 2018:
  program counter:   1875
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2019:
  program counter:   1876
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2020:
  program counter:   1877
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2021:
  program counter:   1878
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 30050, ?thegame["lock"]]

Step 2022:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }]

================================================
Running thread T5: player(4) --> game_leave(?thegame, 4) --> acquire(?thegame["lock"])
method variables:
  binsema: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31954', '{:}', '[]', '30050', '{ "g": ?thegame, "id": 4 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 runnable player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=955 runnable player(3) --> game_leave(?thegame, 3) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=955 runnable player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] }
state id: 5776303
================================================

Step 2023:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(4) --> game_leave(?thegame, 4) --> acquire(?thegame["lock"])

Step 2024:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 2025:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 2026:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }, False]

Step 2027:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }, True]

Step 2028:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }]

Step 2029:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 2030:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2031:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }, ?thegame["lock"]]

Step 2032:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 2033:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }, ?thegame["lock"], True]

Step 2034:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 1, 5, 6 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 4 }]

Step 2035:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2036:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, None]

Step 2037:
  program counter:   1879
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2038:
  program counter:   1880
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                        ^^
  stack:             [{:}, [], 31954, {:}, 4]

Step 2039:
  program counter:   1881
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if id in g->team1:
                              ^
  stack:             [{:}, [], 31954, {:}, 4, ?thegame]

Step 2040:
  program counter:   1882
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if id in g->team1:
                                 ^^^^^
  stack:             [{:}, [], 31954, {:}, 4, ?thegame, "team1"]

Step 2041:
  program counter:   1883
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if id in g->team1:
                              ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 4, ?thegame["team1"]]

Step 2042:
  program counter:   1884
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 1, 5, 6 })
  start expression:  line=58 column=14
  end expression:    line=58 column=21
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, 4, { 1, 5, 6 }]

Step 2043:
  program counter:   1885
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 1, 5, 6 }, 4); check if the second value is a member of the first; push result (False)
  source code:       if id in g->team1:
                        ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2044:
  program counter:   1886
  hvm code:          JumpCond False 1902
  explanation:       pop value (False), compare to False, and jump to 1902 if the same
  source code:       if id in g->team1:
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2045:
  program counter:   1902
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  start statement:   line=60 column=5
  end statement:     line=60 column=24
  source code:       elif id in g->team2:
                          ^^
  stack:             [{:}, [], 31954, {:}, 4]

Step 2046:
  program counter:   1903
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       elif id in g->team2:
                                ^
  stack:             [{:}, [], 31954, {:}, 4, ?thegame]

Step 2047:
  program counter:   1904
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       elif id in g->team2:
                                   ^^^^^
  stack:             [{:}, [], 31954, {:}, 4, ?thegame, "team2"]

Step 2048:
  program counter:   1905
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       elif id in g->team2:
                                ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 4, ?thegame["team2"]]

Step 2049:
  program counter:   1906
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=60 column=16
  end expression:    line=60 column=23
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, 4, { 2, 3, 4 }]

Step 2050:
  program counter:   1907
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3, 4 }, 4); check if the second value is a member of the first; push result (True)
  source code:       elif id in g->team2:
                          ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, True]

Step 2051:
  program counter:   1908
  hvm code:          JumpCond False 1936
  explanation:       pop value (True), compare to False, and jump to 1936 if the same
  source code:       elif id in g->team2:
                     ^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2052:
  program counter:   1909
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=61 column=9
  end statement:     line=61 column=36
  source code:       g->team1 = add(g->team2, id)
                     ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2053:
  program counter:   1910
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = add(g->team2, id)
                        ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2054:
  program counter:   1911
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = add(g->team2, id)
                     ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2055:
  program counter:   1912
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team1 = add(g->team2, id)
                                    ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], []]

Step 2056:
  program counter:   1913
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = add(g->team2, id)
                                    ^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame]

Step 2057:
  program counter:   1914
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team1 = add(g->team2, id)
                                       ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame, "team2"]

Step 2058:
  program counter:   1915
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team1 = add(g->team2, id)
                                    ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame["team2"]]

Step 2059:
  program counter:   1916
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=61 column=24
  end expression:    line=61 column=31
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], { 2, 3, 4 }]

Step 2060:
  program counter:   1917
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, []); insert first value into the second; push result ([{ 2, 3, 4 }])
  source code:       g->team1 = add(g->team2, id)
                                    ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 3, 4 } ]]

Step 2061:
  program counter:   1918
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       g->team1 = add(g->team2, id)
                                              ^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 3, 4 } ], 4]

Step 2062:
  program counter:   1919
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (4, [{ 2, 3, 4 }]); insert first value into the second; push result ([{ 2, 3, 4 }, 4])
  source code:       g->team1 = add(g->team2, id)
                                    ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 3, 4 }, 4 ]]

Step 2063:
  program counter:   1920
  hvm code:          Apply PC(1294)
  explanation:       pop an argument ([{ 2, 3, 4 }, 4]) and call method (1294: "add")
  source code:       g->team1 = add(g->team2, id)
                                ^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4) --> add({ 2, 3, 4 }, 4)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, [ { 2, 3, 4 }, 4 ]]

Step 2064:
  program counter:   1294
  hvm code:          Frame add(s, elt)
  explanation:       pop argument ([{ 2, 3, 4 }, 4]), assign to (s, elt), and run method "add"
  module:            set
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 4, s: { 2, 3, 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }]

Step 2065:
  program counter:   1295
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=23
  source code:       result =  s | {elt}
                               ^

Step 2066:
  program counter:   1296
  hvm code:          LoadVar s
  explanation:       push value ({ 2, 3, 4 }) of variable "s"
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }, { 2, 3, 4 }]

Step 2067:
  program counter:   1297
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=22 column=15
  end expression:    line=22 column=15
  method variables:  { elt: 4 }

Step 2068:
  program counter:   1298
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result =  s | {elt}
                                    ^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }, { 2, 3, 4 }, {}]

Step 2069:
  program counter:   1299
  hvm code:          LoadVar elt
  explanation:       push value (4) of variable "elt"
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }, { 2, 3, 4 }, {}, 4]

Step 2070:
  program counter:   1300
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  method variables:  { }

Step 2071:
  program counter:   1301
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (4, {}); insert first value into the second; push result ({ 4 })
  start expression:  line=22 column=20
  end expression:    line=22 column=22
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }, { 2, 3, 4 }, { 4 }]

Step 2072:
  program counter:   1302
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 4 }, { 2, 3, 4 }); union; push result ({ 2, 3, 4 })
  source code:       result =  s | {elt}
                               ^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }, { 2, 3, 4 }]

Step 2073:
  program counter:   1303
  hvm code:          StoreVar result
  explanation:       pop value ({ 2, 3, 4 }) and store locally in variable \"result\"
  source code:       result =  s | {elt}
                     ^^^^^^^^
  method variables:  { result: { 2, 3, 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30722, { "g": ?thegame, "id": 4 }]

Step 2074:
  program counter:   1304
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=31
  source code:       def add(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 4 }
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], { 2, 3, 4 }]

Step 2075:
  program counter:   1921
  hvm code:          Store
  explanation:       pop value ({ 2, 3, 4 }) and address (?thegame["team1"]) and store
  module:            game
  start statement:   line=61 column=9
  end statement:     line=61 column=36
  source code:       g->team1 = add(g->team2, id)
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 2, 3, 4 }, "team2": { 2, 3, 4 }, "waiting": [] } }
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}]

Step 2076:
  program counter:   1922
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=62 column=9
  end statement:     line=62 column=39
  source code:       g->team2 = remove(g->team2, id)
                     ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2077:
  program counter:   1923
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = remove(g->team2, id)
                        ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team2"]

Step 2078:
  program counter:   1924
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = remove(g->team2, id)
                     ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"]]

Step 2079:
  program counter:   1925
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team2 = remove(g->team2, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], []]

Step 2080:
  program counter:   1926
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team2 = remove(g->team2, id)
                                       ^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], ?thegame]

Step 2081:
  program counter:   1927
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       g->team2 = remove(g->team2, id)
                                          ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], ?thegame, "team2"]

Step 2082:
  program counter:   1928
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       g->team2 = remove(g->team2, id)
                                       ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], ?thegame["team2"]]

Step 2083:
  program counter:   1929
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3, 4 })
  start expression:  line=62 column=27
  end expression:    line=62 column=34
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], { 2, 3, 4 }]

Step 2084:
  program counter:   1930
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, []); insert first value into the second; push result ([{ 2, 3, 4 }])
  source code:       g->team2 = remove(g->team2, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [ { 2, 3, 4 } ]]

Step 2085:
  program counter:   1931
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       g->team2 = remove(g->team2, id)
                                                 ^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [ { 2, 3, 4 } ], 4]

Step 2086:
  program counter:   1932
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=62 column=37
  end expression:    line=62 column=38
  method variables:  { g: ?thegame }

Step 2087:
  program counter:   1933
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (4, [{ 2, 3, 4 }]); insert first value into the second; push result ([{ 2, 3, 4 }, 4])
  source code:       g->team2 = remove(g->team2, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [ { 2, 3, 4 }, 4 ]]

Step 2088:
  program counter:   1934
  hvm code:          Apply PC(1306)
  explanation:       pop an argument ([{ 2, 3, 4 }, 4]) and call method (1306: "remove")
  source code:       g->team2 = remove(g->team2, id)
                                ^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4) --> remove({ 2, 3, 4 }, 4)
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, [ { 2, 3, 4 }, 4 ]]

Step 2089:
  program counter:   1306
  hvm code:          Frame remove(s, elt)
  explanation:       pop argument ([{ 2, 3, 4 }, 4]), assign to (s, elt), and run method "remove"
  module:            set
  start statement:   line=24 column=1
  end statement:     line=24 column=34
  source code:       def remove(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 4, s: { 2, 3, 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }]

Step 2090:
  program counter:   1307
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=22
  source code:       result = s - {elt}
                              ^

Step 2091:
  program counter:   1308
  hvm code:          LoadVar s
  explanation:       push value ({ 2, 3, 4 }) of variable "s"
  start expression:  line=25 column=14
  end expression:    line=25 column=14
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }, { 2, 3, 4 }]

Step 2092:
  program counter:   1309
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=25 column=14
  end expression:    line=25 column=14
  method variables:  { elt: 4 }

Step 2093:
  program counter:   1310
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result = s - {elt}
                                   ^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }, { 2, 3, 4 }, {}]

Step 2094:
  program counter:   1311
  hvm code:          LoadVar elt
  explanation:       push value (4) of variable "elt"
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }, { 2, 3, 4 }, {}, 4]

Step 2095:
  program counter:   1312
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  method variables:  { }

Step 2096:
  program counter:   1313
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (4, {}); insert first value into the second; push result ({ 4 })
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }, { 2, 3, 4 }, { 4 }]

Step 2097:
  program counter:   1314
  hvm code:          2-ary -
  explanation:       pop 2 values ({ 4 }, { 2, 3, 4 }); the second integer minus the first; push result ({ 2, 3 })
  source code:       result = s - {elt}
                              ^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }, { 2, 3 }]

Step 2098:
  program counter:   1315
  hvm code:          StoreVar result
  explanation:       pop value ({ 2, 3 }) and store locally in variable \"result\"
  source code:       result = s - {elt}
                     ^^^^^^^^
  method variables:  { result: { 2, 3 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], [], 30946, { "g": ?thegame }]

Step 2099:
  program counter:   1316
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=24 column=1
  end statement:     line=24 column=34
  source code:       def remove(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, ?thegame["team2"], { 2, 3 }]

Step 2100:
  program counter:   1935
  hvm code:          Store
  explanation:       pop value ({ 2, 3 }) and address (?thegame["team2"]) and store
  module:            game
  start statement:   line=62 column=9
  end statement:     line=62 column=39
  source code:       g->team2 = remove(g->team2, id)
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}]

Step 2101:
  program counter:   1936
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=66 column=5
  end statement:     line=66 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^

Step 2102:
  program counter:   1937
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start expression:  line=66 column=13
  end expression:    line=66 column=13
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2103:
  program counter:   1938
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2104:
  program counter:   1939
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2105:
  program counter:   1940
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 3, 4 })
  start expression:  line=66 column=13
  end expression:    line=66 column=20
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, { 2, 3, 4 }]

Step 2106:
  program counter:   1941
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3, 4 }); compute cardinality; push result (3)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 3]

Step 2107:
  program counter:   1942
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31954, {:}, 3, 0]

Step 2108:
  program counter:   1943
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 3); check if both values are the same; push result (False)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2109:
  program counter:   1944
  hvm code:          JumpCond False 1953
  explanation:       pop value (False), compare to False, and jump to 1953 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2110:
  program counter:   1953
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=66 column=8
  end expression:    line=66 column=52
  stack:             [{:}, [], 31954, {:}, False]

Step 2111:
  program counter:   1954
  hvm code:          JumpCond False 1960
  explanation:       pop value (False), compare to False, and jump to 1960 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2112:
  program counter:   1960
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2113:
  program counter:   1961
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=69 column=14
  end expression:    line=69 column=14
  method variables:  { }

Step 2114:
  program counter:   1962
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2115:
  program counter:   1963
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2116:
  program counter:   1964
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4) --> release(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 31426, ?thegame["lock"]]

Step 2117:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2118:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4) --> release(?thegame["lock"])

Step 2119:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2120:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2121:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2122:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, True]

Step 2123:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2124:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2125:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2126:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2127:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 2128:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"], False]

Step 2129:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2130:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 2131:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4) --> game_leave(?thegame, 4)
  stack:             [{:}, [], 31954, {:}, None]

Step 2132:
  program counter:   1965
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2133:
  program counter:   1966
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(4)
  stack:             [{:}, None]

Step 2134:
  program counter:   1998
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 2135:
  program counter:   1999
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Running thread T2: player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
method variables:
  c: ?thegame["players"]
  cnt: 0
  ctx: CONTEXT({'type': 'pc', 'value': '1004'})
  lk: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31634', '{ "self": 1 }', '[]', '29586', '{ "g": ?thegame, "id": 1 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=955 runnable player(3) --> game_leave(?thegame, 3) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T5: pc=1999 terminated player(4)
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=955 runnable player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": {:}, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] }
state id: 6131215
================================================

Step 2136:
  program counter:   1032
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=55 column=6
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])

Step 2137:
  program counter:   1033
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):

Step 2138:
  program counter:   1034
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                           ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 2139:
  program counter:   1035
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                          ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, False]

Step 2140:
  program counter:   1036
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, True]

Step 2141:
  program counter:   1037
  hvm code:          JumpCond False 1050
  explanation:       pop value (True), compare to False, and jump to 1050 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2142:
  program counter:   1038
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605)]

Step 2143:
  program counter:   1039
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), []]

Step 2144:
  program counter:   1040
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                      ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [], ?thegame["players"]]

Step 2145:
  program counter:   1041
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [], {:}]

Step 2146:
  program counter:   1042
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ {:} ]]

Step 2147:
  program counter:   1043
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                         ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 2148:
  program counter:   1044
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2149:
  program counter:   1045
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 2150:
  program counter:   1046
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and call method (605: "multiplicity")
  start expression:  line=53 column=40
  end expression:    line=53 column=64
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, [], 16738, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2151:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, 0]

Step 2152:
  program counter:   1047
  hvm code:          LoadVar cnt
  explanation:       push value (0) of variable "cnt"
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                 ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, 0, 0]

Step 2153:
  program counter:   1048
  hvm code:          2-ary <=
  explanation:       pop 2 values (0, 0); check if second value is less than or equal to the first; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, True]

Step 2154:
  program counter:   1049
  hvm code:          Jump 1051
  explanation:       set program counter to 1051
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                               ^^^

Step 2155:
  program counter:   1051
  hvm code:          JumpCond False 1056
  explanation:       pop value (True), compare to False, and jump to 1056 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2156:
  program counter:   1052
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                    ^
  method variables:  { cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 2157:
  program counter:   1053
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 2158:
  program counter:   1054
  hvm code:          DelVar ctx
  explanation:       delete method variable ctx
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { lk: ?thegame["lock"] }

Step 2159:
  program counter:   1055
  hvm code:          Jump 1059
  explanation:       set program counter to 1059
  start expression:  line=53 column=72
  end expression:    line=53 column=72

Step 2160:
  program counter:   1059
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2161:
  program counter:   1060
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=54 column=13
  end statement:     line=54 column=22
  source code:       !lk = True
                      ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 2162:
  program counter:   1061
  hvm code:          DelVar lk
  explanation:       delete method variable lk
  start expression:  line=54 column=14
  end expression:    line=54 column=15
  method variables:  { }

Step 2163:
  program counter:   1062
  hvm code:          Push True
  explanation:       push constant True
  source code:       !lk = True
                           ^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"], True]

Step 2164:
  program counter:   1063
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !lk = True
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": {:}, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2165:
  program counter:   1064
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2166:
  program counter:   1065
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, None]

Step 2167:
  program counter:   1850
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 2168:
  program counter:   1851
  hvm code:          Jump 1800
  explanation:       set program counter to 1800
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2169:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame]

Step 2170:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame, "team1"]

Step 2171:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, ?thegame["team1"]]

Step 2172:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 3, 4 })
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, { 2, 3, 4 }]

Step 2173:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3, 4 }); compute cardinality; push result (3)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 3]

Step 2174:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 1 }, 3, ?thegame]

Step 2175:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 3, ?thegame, "team2"]

Step 2176:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 3, ?thegame["team2"]]

Step 2177:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3 })
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 31634, { "self": 1 }, 3, { 2, 3 }]

Step 2178:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3 }); compute cardinality; push result (2)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, 3, 2]

Step 2179:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (2, 3); check if the values are unequal; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, True]

Step 2180:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (True), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 2181:
  program counter:   1838
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=46 column=11
  end expression:    line=46 column=117
  stack:             [{:}, [], 31634, { "self": 1 }, True]

Step 2182:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (True), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }]

Step 2183:
  program counter:   1840
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, []]

Step 2184:
  program counter:   1841
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], ?thegame]

Step 2185:
  program counter:   1842
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], ?thegame, "players"]

Step 2186:
  program counter:   1843
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], ?thegame["players"]]

Step 2187:
  program counter:   1844
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ]]

Step 2188:
  program counter:   1845
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ], ?thegame]

Step 2189:
  program counter:   1846
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 2190:
  program counter:   1847
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 2191:
  program counter:   1848
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 2192:
  program counter:   1849
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, [ ?thegame["players"], ?thegame["lock"] ]]

Step 2193:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2194:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, 0]

Step 2195:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2196:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 2197:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, []]

Step 2198:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2199:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 2200:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2201:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])

Step 2202:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605)]

Step 2203:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), []]

Step 2204:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [], ?thegame["players"]]

Step 2205:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [], {:}]

Step 2206:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ {:} ]]

Step 2207:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 2208:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2209:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 2210:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, [], 16242, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2211:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, 0]

Step 2212:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2213:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"]]

Step 2214:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696)]

Step 2215:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), []]

Step 2216:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 2217:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [], {:}]

Step 2218:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ {:} ]]

Step 2219:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 2220:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2221:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])], PC(696)); push result (?PC(696)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], ?PC(696)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 2222:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> add({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], [], 16418, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2223:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 2224:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2225:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 2226:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }, ?thegame["lock"], False]

Step 2227:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 1 }, [], 29586, { "g": ?thegame, "id": 1 }]

Step 2228:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T4: player(3) --> game_leave(?thegame, 3) --> acquire(?thegame["lock"])
method variables:
  binsema: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31954', '{:}', '[]', '30050', '{ "g": ?thegame, "id": 3 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1032 runnable player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T5: pc=1999 terminated player(4)
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=955 runnable player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] }
state id: 6257793
================================================

Step 2229:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(3) --> game_leave(?thegame, 3) --> acquire(?thegame["lock"])

Step 2230:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 2231:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 2232:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }, False]

Step 2233:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }, True]

Step 2234:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }]

Step 2235:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 2236:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2237:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }, ?thegame["lock"]]

Step 2238:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 2239:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }, ?thegame["lock"], True]

Step 2240:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 3, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 3 }]

Step 2241:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2242:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 3 }
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}, None]

Step 2243:
  program counter:   1879
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2244:
  program counter:   1880
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                        ^^
  stack:             [{:}, [], 31954, {:}, 3]

Step 2245:
  program counter:   1881
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if id in g->team1:
                              ^
  stack:             [{:}, [], 31954, {:}, 3, ?thegame]

Step 2246:
  program counter:   1882
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if id in g->team1:
                                 ^^^^^
  stack:             [{:}, [], 31954, {:}, 3, ?thegame, "team1"]

Step 2247:
  program counter:   1883
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if id in g->team1:
                              ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 3, ?thegame["team1"]]

Step 2248:
  program counter:   1884
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 3, 4 })
  start expression:  line=58 column=14
  end expression:    line=58 column=21
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}, 3, { 2, 3, 4 }]

Step 2249:
  program counter:   1885
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3, 4 }, 3); check if the second value is a member of the first; push result (True)
  source code:       if id in g->team1:
                        ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, True]

Step 2250:
  program counter:   1886
  hvm code:          JumpCond False 1902
  explanation:       pop value (True), compare to False, and jump to 1902 if the same
  source code:       if id in g->team1:
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2251:
  program counter:   1887
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=59 column=9
  end statement:     line=59 column=39
  source code:       g->team1 = remove(g->team1, id)
                     ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2252:
  program counter:   1888
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = remove(g->team1, id)
                        ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2253:
  program counter:   1889
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = remove(g->team1, id)
                     ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2254:
  program counter:   1890
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], []]

Step 2255:
  program counter:   1891
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = remove(g->team1, id)
                                       ^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame]

Step 2256:
  program counter:   1892
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = remove(g->team1, id)
                                          ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame, "team1"]

Step 2257:
  program counter:   1893
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame["team1"]]

Step 2258:
  program counter:   1894
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 3, 4 })
  start expression:  line=59 column=27
  end expression:    line=59 column=34
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], { 2, 3, 4 }]

Step 2259:
  program counter:   1895
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3, 4 }, []); insert first value into the second; push result ([{ 2, 3, 4 }])
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 3, 4 } ]]

Step 2260:
  program counter:   1896
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  source code:       g->team1 = remove(g->team1, id)
                                                 ^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 3, 4 } ], 3]

Step 2261:
  program counter:   1897
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=59 column=37
  end expression:    line=59 column=38
  method variables:  { g: ?thegame }

Step 2262:
  program counter:   1898
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (3, [{ 2, 3, 4 }]); insert first value into the second; push result ([{ 2, 3, 4 }, 3])
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 3, 4 }, 3 ]]

Step 2263:
  program counter:   1899
  hvm code:          Apply PC(1306)
  explanation:       pop an argument ([{ 2, 3, 4 }, 3]) and call method (1306: "remove")
  source code:       g->team1 = remove(g->team1, id)
                                ^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_leave(?thegame, 3) --> remove({ 2, 3, 4 }, 3)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, [ { 2, 3, 4 }, 3 ]]

Step 2264:
  program counter:   1306
  hvm code:          Frame remove(s, elt)
  explanation:       pop argument ([{ 2, 3, 4 }, 3]), assign to (s, elt), and run method "remove"
  module:            set
  start statement:   line=24 column=1
  end statement:     line=24 column=34
  source code:       def remove(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 3, s: { 2, 3, 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }]

Step 2265:
  program counter:   1307
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=22
  source code:       result = s - {elt}
                              ^

Step 2266:
  program counter:   1308
  hvm code:          LoadVar s
  explanation:       push value ({ 2, 3, 4 }) of variable "s"
  start expression:  line=25 column=14
  end expression:    line=25 column=14
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 3, 4 }]

Step 2267:
  program counter:   1309
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=25 column=14
  end expression:    line=25 column=14
  method variables:  { elt: 3 }

Step 2268:
  program counter:   1310
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result = s - {elt}
                                   ^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 3, 4 }, {}]

Step 2269:
  program counter:   1311
  hvm code:          LoadVar elt
  explanation:       push value (3) of variable "elt"
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 3, 4 }, {}, 3]

Step 2270:
  program counter:   1312
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  method variables:  { }

Step 2271:
  program counter:   1313
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (3, {}); insert first value into the second; push result ({ 3 })
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 3, 4 }, { 3 }]

Step 2272:
  program counter:   1314
  hvm code:          2-ary -
  explanation:       pop 2 values ({ 3 }, { 2, 3, 4 }); the second integer minus the first; push result ({ 2, 4 })
  source code:       result = s - {elt}
                              ^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 4 }]

Step 2273:
  program counter:   1315
  hvm code:          StoreVar result
  explanation:       pop value ({ 2, 4 }) and store locally in variable \"result\"
  source code:       result = s - {elt}
                     ^^^^^^^^
  method variables:  { result: { 2, 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }]

Step 2274:
  program counter:   1316
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=24 column=1
  end statement:     line=24 column=34
  source code:       def remove(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], { 2, 4 }]

Step 2275:
  program counter:   1900
  hvm code:          Store
  explanation:       pop value ({ 2, 4 }) and address (?thegame["team1"]) and store
  module:            game
  start statement:   line=59 column=9
  end statement:     line=59 column=39
  source code:       g->team1 = remove(g->team1, id)
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}]

Step 2276:
  program counter:   1901
  hvm code:          Jump 1936
  explanation:       set program counter to 1936
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                     ^^^^^^^^^^^^^^^^^^

Step 2277:
  program counter:   1936
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=66 column=5
  end statement:     line=66 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^

Step 2278:
  program counter:   1937
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start expression:  line=66 column=13
  end expression:    line=66 column=13
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2279:
  program counter:   1938
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2280:
  program counter:   1939
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2281:
  program counter:   1940
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=66 column=13
  end expression:    line=66 column=20
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}, { 2, 4 }]

Step 2282:
  program counter:   1941
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 4 }); compute cardinality; push result (2)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 2]

Step 2283:
  program counter:   1942
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31954, {:}, 2, 0]

Step 2284:
  program counter:   1943
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 2); check if both values are the same; push result (False)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2285:
  program counter:   1944
  hvm code:          JumpCond False 1953
  explanation:       pop value (False), compare to False, and jump to 1953 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2286:
  program counter:   1953
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=66 column=8
  end expression:    line=66 column=52
  stack:             [{:}, [], 31954, {:}, False]

Step 2287:
  program counter:   1954
  hvm code:          JumpCond False 1960
  explanation:       pop value (False), compare to False, and jump to 1960 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2288:
  program counter:   1960
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2289:
  program counter:   1961
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=69 column=14
  end expression:    line=69 column=14
  method variables:  { }

Step 2290:
  program counter:   1962
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2291:
  program counter:   1963
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2292:
  program counter:   1964
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_leave(?thegame, 3) --> release(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 31426, ?thegame["lock"]]

Step 2293:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2294:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(3) --> game_leave(?thegame, 3) --> release(?thegame["lock"])

Step 2295:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2296:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2297:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2298:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, True]

Step 2299:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2300:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2301:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2302:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2303:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 2304:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"], False]

Step 2305:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2306:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 2307:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3) --> game_leave(?thegame, 3)
  stack:             [{:}, [], 31954, {:}, None]

Step 2308:
  program counter:   1965
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2309:
  program counter:   1966
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(3)
  stack:             [{:}, None]

Step 2310:
  program counter:   1998
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 2311:
  program counter:   1999
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Running thread T3: player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
method variables:
  c: ?thegame["players"]
  cnt: 0
  ctx: CONTEXT({'type': 'pc', 'value': '1004'})
  lk: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31634', '{ "self": 2 }', '[]', '29586', '{ "g": ?thegame, "id": 2 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=1999 terminated player(3)
  T5: pc=1999 terminated player(4)
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=955 runnable player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] }
state id: 6433578
================================================

Step 2312:
  program counter:   1032
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=55 column=6
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])

Step 2313:
  program counter:   1033
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):

Step 2314:
  program counter:   1034
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                           ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 2315:
  program counter:   1035
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                          ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, False]

Step 2316:
  program counter:   1036
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, True]

Step 2317:
  program counter:   1037
  hvm code:          JumpCond False 1050
  explanation:       pop value (True), compare to False, and jump to 1050 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 2318:
  program counter:   1038
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605)]

Step 2319:
  program counter:   1039
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), []]

Step 2320:
  program counter:   1040
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                      ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [], ?thegame["players"]]

Step 2321:
  program counter:   1041
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 })
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 2322:
  program counter:   1042
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 2323:
  program counter:   1043
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])) of variable "ctx"
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                         ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 2324:
  program counter:   1044
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                     ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2325:
  program counter:   1045
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]])
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 2326:
  program counter:   1046
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }])]) and call method (605: "multiplicity")
  start expression:  line=53 column=40
  end expression:    line=53 column=64
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 1 },[],29586,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],31634,{ "self": 2 },[],29586,{ "g": ?thegame, "id": 2 }]))
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, [], 16738, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 2327:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, 0]

Step 2328:
  program counter:   1047
  hvm code:          LoadVar cnt
  explanation:       push value (0) of variable "cnt"
  module:            synch
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                 ^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, 0, 0]

Step 2329:
  program counter:   1048
  hvm code:          2-ary <=
  explanation:       pop 2 values (0, 0); check if second value is less than or equal to the first; push result (True)
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, True]

Step 2330:
  program counter:   1049
  hvm code:          Jump 1051
  explanation:       set program counter to 1051
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                               ^^^

Step 2331:
  program counter:   1051
  hvm code:          JumpCond False 1056
  explanation:       pop value (True), compare to False, and jump to 1056 if the same
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 2332:
  program counter:   1052
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                                                                    ^
  method variables:  { cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 2333:
  program counter:   1053
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }

Step 2334:
  program counter:   1054
  hvm code:          DelVar ctx
  explanation:       delete method variable ctx
  start expression:  line=53 column=72
  end expression:    line=53 column=72
  method variables:  { lk: ?thegame["lock"] }

Step 2335:
  program counter:   1055
  hvm code:          Jump 1059
  explanation:       set program counter to 1059
  start expression:  line=53 column=72
  end expression:    line=53 column=72

Step 2336:
  program counter:   1059
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2337:
  program counter:   1060
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=54 column=13
  end statement:     line=54 column=22
  source code:       !lk = True
                      ^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 2338:
  program counter:   1061
  hvm code:          DelVar lk
  explanation:       delete method variable lk
  start expression:  line=54 column=14
  end expression:    line=54 column=15
  method variables:  { }

Step 2339:
  program counter:   1062
  hvm code:          Push True
  explanation:       push constant True
  source code:       !lk = True
                           ^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }, ?thegame["lock"], True]

Step 2340:
  program counter:   1063
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !lk = True
                     ^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29586, { "g": ?thegame, "id": 2 }]

Step 2341:
  program counter:   1064
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=53 column=20
  end statement:     line=53 column=72
  source code:       atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2342:
  program counter:   1065
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 2 }
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, None]

Step 2343:
  program counter:   1850
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=47 column=9
  end statement:     line=47 column=35
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2344:
  program counter:   1851
  hvm code:          Jump 1800
  explanation:       set program counter to 1800
  start statement:   line=46 column=5
  end statement:     line=46 column=118
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2345:
  program counter:   1800
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 2346:
  program counter:   1801
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "team1"]

Step 2347:
  program counter:   1802
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["team1"]]

Step 2348:
  program counter:   1803
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=46 column=16
  end expression:    line=46 column=23
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, { 2, 4 }]

Step 2349:
  program counter:   1804
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 4 }); compute cardinality; push result (2)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2]

Step 2350:
  program counter:   1805
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, ?thegame]

Step 2351:
  program counter:   1806
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                    ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, ?thegame, "team2"]

Step 2352:
  program counter:   1807
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                 ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, ?thegame["team2"]]

Step 2353:
  program counter:   1808
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3 })
  start expression:  line=46 column=33
  end expression:    line=46 column=40
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, 2, { 2, 3 }]

Step 2354:
  program counter:   1809
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 3 }); compute cardinality; push result (2)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                             ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, 2]

Step 2355:
  program counter:   1810
  hvm code:          2-ary !=
  explanation:       pop 2 values (2, 2); check if the values are unequal; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, False]

Step 2356:
  program counter:   1811
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2357:
  program counter:   1812
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 2358:
  program counter:   1813
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                       ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "team1"]

Step 2359:
  program counter:   1814
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                    ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["team1"]]

Step 2360:
  program counter:   1815
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=46 column=52
  end expression:    line=46 column=59
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, { 2, 4 }]

Step 2361:
  program counter:   1816
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 4 }); compute cardinality; push result (2)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2]

Step 2362:
  program counter:   1817
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                 ^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, 0]

Step 2363:
  program counter:   1818
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 2); check if both values are the same; push result (False)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, False]

Step 2364:
  program counter:   1819
  hvm code:          JumpCond True 1838
  explanation:       pop value (False), compare to True, and jump to 1838 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2365:
  program counter:   1820
  hvm code:          LoadVar id
  explanation:       push value (2) of variable "id"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2]

Step 2366:
  program counter:   1821
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, ?thegame]

Step 2367:
  program counter:   1822
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                      ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, ?thegame, "team1"]

Step 2368:
  program counter:   1823
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                                   ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, 2, ?thegame["team1"]]

Step 2369:
  program counter:   1824
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=46 column=83
  end expression:    line=46 column=90
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, 2, { 2, 4 }]

Step 2370:
  program counter:   1825
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 4 }, 2); check if the second value is a member of the first; push result (True)
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, True]

Step 2371:
  program counter:   1826
  hvm code:          1-ary not
  explanation:       pop a value (True); logical not; push result (False)
  start expression:  line=46 column=73
  end expression:    line=46 column=90
  stack:             [{:}, [], 31634, { "self": 2 }, False]

Step 2372:
  program counter:   1827
  hvm code:          JumpCond False 1836
  explanation:       pop value (False), compare to False, and jump to 1836 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2373:
  program counter:   1836
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=46 column=72
  end expression:    line=46 column=116
  stack:             [{:}, [], 31634, { "self": 2 }, False]

Step 2374:
  program counter:   1837
  hvm code:          Jump 1839
  explanation:       set program counter to 1839
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                                                            ^^

Step 2375:
  program counter:   1839
  hvm code:          JumpCond False 1852
  explanation:       pop value (False), compare to False, and jump to 1852 if the same
  source code:       while (len(g->team1) != len(g->team2)) or (len(g->team1) == 0) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2376:
  program counter:   1852
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=50 column=5
  end statement:     line=50 column=32
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }

Step 2377:
  program counter:   1853
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start expression:  line=50 column=14
  end expression:    line=50 column=31
  stack:             [{:}, [], 31634, { "self": 2 }, []]

Step 2378:
  program counter:   1854
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                              ^
  stack:             [{:}, [], 31634, { "self": 2 }, [], ?thegame]

Step 2379:
  program counter:   1855
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       teams = (g->team1, g->team2)
                                 ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], ?thegame, "team1"]

Step 2380:
  program counter:   1856
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], ?thegame["team1"]]

Step 2381:
  program counter:   1857
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=50 column=14
  end expression:    line=50 column=21
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, [], { 2, 4 }]

Step 2382:
  program counter:   1858
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 4 }, []); insert first value into the second; push result ([{ 2, 4 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ { 2, 4 } ]]

Step 2383:
  program counter:   1859
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       teams = (g->team1, g->team2)
                                        ^
  stack:             [{:}, [], 31634, { "self": 2 }, [ { 2, 4 } ], ?thegame]

Step 2384:
  program counter:   1860
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       teams = (g->team1, g->team2)
                                           ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ { 2, 4 } ], ?thegame, "team2"]

Step 2385:
  program counter:   1861
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       teams = (g->team1, g->team2)
                                        ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ { 2, 4 } ], ?thegame["team2"]]

Step 2386:
  program counter:   1862
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3 })
  start expression:  line=50 column=24
  end expression:    line=50 column=31
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, [ { 2, 4 } ], { 2, 3 }]

Step 2387:
  program counter:   1863
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 3 }, [{ 2, 4 }]); insert first value into the second; push result ([{ 2, 4 }, { 2, 3 }])
  source code:       teams = (g->team1, g->team2)
                              ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [ { 2, 4 }, { 2, 3 } ]]

Step 2388:
  program counter:   1864
  hvm code:          StoreVar teams
  explanation:       pop value ([{ 2, 4 }, { 2, 3 }]) and store locally in variable \"teams\"
  source code:       teams = (g->team1, g->team2)
                     ^^^^^^^
  method variables:  { g: ?thegame, teams: [ { 2, 4 }, { 2, 3 } ] }
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2389:
  program counter:   1865
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame]

Step 2390:
  program counter:   1866
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=52 column=14
  end expression:    line=52 column=14
  method variables:  { teams: [ { 2, 4 }, { 2, 3 } ] }

Step 2391:
  program counter:   1867
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame, "lock"]

Step 2392:
  program counter:   1868
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, ?thegame["lock"]]

Step 2393:
  program counter:   1869
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> release(?thegame["lock"])
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, ?thegame["lock"]]

Step 2394:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }]

Step 2395:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(2) --> game_join(?thegame, 2) --> release(?thegame["lock"])

Step 2396:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2397:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2398:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }, ?thegame["lock"]]

Step 2399:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }, True]

Step 2400:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }]

Step 2401:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2402:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2403:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }, ?thegame["lock"]]

Step 2404:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 2405:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }, ?thegame["lock"], False]

Step 2406:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31634, { "self": 2 }, [], 29906, { "teams": [ { 2, 4 }, { 2, 3 } ] }]

Step 2407:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 2408:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { teams: [ { 2, 4 }, { 2, 3 } ] }
  call trace:        player(2) --> game_join(?thegame, 2)
  stack:             [{:}, [], 31634, { "self": 2 }, None]

Step 2409:
  program counter:   1870
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=52 column=5
  end statement:     line=52 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31634, { "self": 2 }]

Step 2410:
  program counter:   1871
  hvm code:          ReturnOp(teams)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=35 column=1
  end statement:     line=35 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 2 }
  call trace:        player(2)
  stack:             [{:}, [ { 2, 4 }, { 2, 3 } ]]

Step 2411:
  program counter:   1978
  hvm code:          StoreVar (team1, team2)
  explanation:       pop value ([{ 2, 4 }, { 2, 3 }]) and store locally in variable \"(team1, team2)\"
  module:            __main__
  start statement:   line=6 column=5
  end statement:     line=6 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 2, team1: { 2, 4 }, team2: { 2, 3 } }
  stack:             [{:}]

Step 2412:
  program counter:   1979
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=9
  end statement:     line=7 column=38
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2413:
  program counter:   1980
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 2414:
  program counter:   1981
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       assert self in (team1 | team2)
                            ^^^^
  stack:             [{:}, 2]

Step 2415:
  program counter:   1982
  hvm code:          LoadVar team1
  explanation:       push value ({ 2, 4 }) of variable "team1"
  source code:       assert self in (team1 | team2)
                                     ^^^^^
  stack:             [{:}, 2, { 2, 4 }]

Step 2416:
  program counter:   1983
  hvm code:          DelVar team1
  explanation:       delete method variable team1
  start expression:  line=7 column=25
  end expression:    line=7 column=29
  method variables:  { self: 2, team2: { 2, 3 } }

Step 2417:
  program counter:   1984
  hvm code:          LoadVar team2
  explanation:       push value ({ 2, 3 }) of variable "team2"
  source code:       assert self in (team1 | team2)
                                             ^^^^^
  stack:             [{:}, 2, { 2, 4 }, { 2, 3 }]

Step 2418:
  program counter:   1985
  hvm code:          DelVar team2
  explanation:       delete method variable team2
  start expression:  line=7 column=33
  end expression:    line=7 column=37
  method variables:  { self: 2 }

Step 2419:
  program counter:   1986
  hvm code:          2-ary |
  explanation:       pop 2 values ({ 2, 3 }, { 2, 4 }); union; push result ({ 2, 3, 4 })
  source code:       assert self in (team1 | team2)
                                     ^^^^^^^^^^^^^
  stack:             [{:}, 2, { 2, 3, 4 }]

Step 2420:
  program counter:   1987
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3, 4 }, 2); check if the second value is a member of the first; push result (True)
  source code:       assert self in (team1 | team2)
                            ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 2421:
  program counter:   1988
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert self in (team1 | team2)
                     ^^^^^^
  stack:             [{:}]

Step 2422:
  program counter:   1989
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert self in (team1 | team2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 2423:
  program counter:   1990
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=7 column=9
  end expression:    line=7 column=38

Step 2424:
  program counter:   1991
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 2425:
  program counter:   1992
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       game_leave(?thegame, self)
                                 ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 2426:
  program counter:   1993
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 2427:
  program counter:   1994
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       game_leave(?thegame, self)
                                          ^^^^
  stack:             [{:}, [ ?thegame ], 2]

Step 2428:
  program counter:   1995
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=9 column=26
  end expression:    line=9 column=29
  method variables:  { }

Step 2429:
  program counter:   1996
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [?thegame]); insert first value into the second; push result ([?thegame, 2])
  source code:       game_leave(?thegame, self)
                                ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 2 ]]

Step 2430:
  program counter:   1997
  hvm code:          Apply PC(1874)
  explanation:       pop an argument ([?thegame, 2]) and call method (1874: "game_leave")
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, [ ?thegame, 2 ]]

Step 2431:
  program counter:   1874
  hvm code:          Frame game_leave(g, id)
  explanation:       pop argument ([?thegame, 2]), assign to (g, id), and run method "game_leave"
  module:            game
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 2 }
  stack:             [{:}, [], 31954, {:}]

Step 2432:
  program counter:   1875
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2433:
  program counter:   1876
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2434:
  program counter:   1877
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2435:
  program counter:   1878
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_leave(?thegame, 2) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 30050, ?thegame["lock"]]

Step 2436:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }]

================================================
Running thread T7: player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])
method variables:
  binsema: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31954', '{:}', '[]', '30050', '{ "g": ?thegame, "id": 6 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=955 runnable player(2) --> game_leave(?thegame, 2) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T4: pc=1999 terminated player(3)
  T5: pc=1999 terminated player(4)
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] }
state id: 6625852
================================================

Step 2437:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(6) --> game_leave(?thegame, 6) --> acquire(?thegame["lock"])

Step 2438:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 2439:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 2440:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }, False]

Step 2441:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }, True]

Step 2442:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }]

Step 2443:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 2444:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2445:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }, ?thegame["lock"]]

Step 2446:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 2447:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }, ?thegame["lock"], True]

Step 2448:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 6 }]

Step 2449:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2450:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 6 }
  call trace:        player(6) --> game_leave(?thegame, 6)
  stack:             [{:}, [], 31954, {:}, None]

Step 2451:
  program counter:   1879
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2452:
  program counter:   1880
  hvm code:          LoadVar id
  explanation:       push value (6) of variable "id"
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                        ^^
  stack:             [{:}, [], 31954, {:}, 6]

Step 2453:
  program counter:   1881
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if id in g->team1:
                              ^
  stack:             [{:}, [], 31954, {:}, 6, ?thegame]

Step 2454:
  program counter:   1882
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if id in g->team1:
                                 ^^^^^
  stack:             [{:}, [], 31954, {:}, 6, ?thegame, "team1"]

Step 2455:
  program counter:   1883
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if id in g->team1:
                              ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 6, ?thegame["team1"]]

Step 2456:
  program counter:   1884
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=58 column=14
  end expression:    line=58 column=21
  call trace:        player(6) --> game_leave(?thegame, 6)
  stack:             [{:}, [], 31954, {:}, 6, { 2, 4 }]

Step 2457:
  program counter:   1885
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 4 }, 6); check if the second value is a member of the first; push result (False)
  source code:       if id in g->team1:
                        ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2458:
  program counter:   1886
  hvm code:          JumpCond False 1902
  explanation:       pop value (False), compare to False, and jump to 1902 if the same
  source code:       if id in g->team1:
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2459:
  program counter:   1902
  hvm code:          LoadVar id
  explanation:       push value (6) of variable "id"
  start statement:   line=60 column=5
  end statement:     line=60 column=24
  source code:       elif id in g->team2:
                          ^^
  stack:             [{:}, [], 31954, {:}, 6]

Step 2460:
  program counter:   1903
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       elif id in g->team2:
                                ^
  stack:             [{:}, [], 31954, {:}, 6, ?thegame]

Step 2461:
  program counter:   1904
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       elif id in g->team2:
                                   ^^^^^
  stack:             [{:}, [], 31954, {:}, 6, ?thegame, "team2"]

Step 2462:
  program counter:   1905
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       elif id in g->team2:
                                ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 6, ?thegame["team2"]]

Step 2463:
  program counter:   1906
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3 })
  start expression:  line=60 column=16
  end expression:    line=60 column=23
  call trace:        player(6) --> game_leave(?thegame, 6)
  stack:             [{:}, [], 31954, {:}, 6, { 2, 3 }]

Step 2464:
  program counter:   1907
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3 }, 6); check if the second value is a member of the first; push result (False)
  source code:       elif id in g->team2:
                          ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2465:
  program counter:   1908
  hvm code:          JumpCond False 1936
  explanation:       pop value (False), compare to False, and jump to 1936 if the same
  source code:       elif id in g->team2:
                     ^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2466:
  program counter:   1936
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=66 column=5
  end statement:     line=66 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  method variables:  { g: ?thegame }

Step 2467:
  program counter:   1937
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start expression:  line=66 column=13
  end expression:    line=66 column=13
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2468:
  program counter:   1938
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2469:
  program counter:   1939
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2470:
  program counter:   1940
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=66 column=13
  end expression:    line=66 column=20
  call trace:        player(6) --> game_leave(?thegame, 6)
  stack:             [{:}, [], 31954, {:}, { 2, 4 }]

Step 2471:
  program counter:   1941
  hvm code:          1-ary len
  explanation:       pop a value ({ 2, 4 }); compute cardinality; push result (2)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 2]

Step 2472:
  program counter:   1942
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31954, {:}, 2, 0]

Step 2473:
  program counter:   1943
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 2); check if both values are the same; push result (False)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2474:
  program counter:   1944
  hvm code:          JumpCond False 1953
  explanation:       pop value (False), compare to False, and jump to 1953 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2475:
  program counter:   1953
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=66 column=8
  end expression:    line=66 column=52
  stack:             [{:}, [], 31954, {:}, False]

Step 2476:
  program counter:   1954
  hvm code:          JumpCond False 1960
  explanation:       pop value (False), compare to False, and jump to 1960 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2477:
  program counter:   1960
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2478:
  program counter:   1961
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=69 column=14
  end expression:    line=69 column=14
  method variables:  { }

Step 2479:
  program counter:   1962
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2480:
  program counter:   1963
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2481:
  program counter:   1964
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_leave(?thegame, 6) --> release(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 31426, ?thegame["lock"]]

Step 2482:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2483:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(6) --> game_leave(?thegame, 6) --> release(?thegame["lock"])

Step 2484:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2485:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2486:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2487:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, True]

Step 2488:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2489:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2490:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2491:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2492:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 2493:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"], False]

Step 2494:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2495:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 2496:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6) --> game_leave(?thegame, 6)
  stack:             [{:}, [], 31954, {:}, None]

Step 2497:
  program counter:   1965
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2498:
  program counter:   1966
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(6)
  stack:             [{:}, None]

Step 2499:
  program counter:   1998
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 2500:
  program counter:   1999
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Running thread T3: player(2) --> game_leave(?thegame, 2) --> acquire(?thegame["lock"])
method variables:
  binsema: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31954', '{:}', '[]', '30050', '{ "g": ?thegame, "id": 2 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T4: pc=1999 terminated player(3)
  T5: pc=1999 terminated player(4)
  T6: pc=955 runnable player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
    about to execute synch:35:     atomically when not !binsema:
  T7: pc=1999 terminated player(6)
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] }
state id: 6686749
================================================

Step 2501:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  module:            synch
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(2) --> game_leave(?thegame, 2) --> acquire(?thegame["lock"])

Step 2502:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 2503:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 2504:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }, False]

Step 2505:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }, True]

Step 2506:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }]

Step 2507:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 2508:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2509:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }, ?thegame["lock"]]

Step 2510:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 2511:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }, ?thegame["lock"], True]

Step 2512:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 2, 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 2 }]

Step 2513:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2514:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 2 }
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}, None]

Step 2515:
  program counter:   1879
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2516:
  program counter:   1880
  hvm code:          LoadVar id
  explanation:       push value (2) of variable "id"
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                        ^^
  stack:             [{:}, [], 31954, {:}, 2]

Step 2517:
  program counter:   1881
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if id in g->team1:
                              ^
  stack:             [{:}, [], 31954, {:}, 2, ?thegame]

Step 2518:
  program counter:   1882
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if id in g->team1:
                                 ^^^^^
  stack:             [{:}, [], 31954, {:}, 2, ?thegame, "team1"]

Step 2519:
  program counter:   1883
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if id in g->team1:
                              ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 2, ?thegame["team1"]]

Step 2520:
  program counter:   1884
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=58 column=14
  end expression:    line=58 column=21
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}, 2, { 2, 4 }]

Step 2521:
  program counter:   1885
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 4 }, 2); check if the second value is a member of the first; push result (True)
  source code:       if id in g->team1:
                        ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, True]

Step 2522:
  program counter:   1886
  hvm code:          JumpCond False 1902
  explanation:       pop value (True), compare to False, and jump to 1902 if the same
  source code:       if id in g->team1:
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2523:
  program counter:   1887
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=59 column=9
  end statement:     line=59 column=39
  source code:       g->team1 = remove(g->team1, id)
                     ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2524:
  program counter:   1888
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = remove(g->team1, id)
                        ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2525:
  program counter:   1889
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = remove(g->team1, id)
                     ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2526:
  program counter:   1890
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], []]

Step 2527:
  program counter:   1891
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->team1 = remove(g->team1, id)
                                       ^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame]

Step 2528:
  program counter:   1892
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       g->team1 = remove(g->team1, id)
                                          ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame, "team1"]

Step 2529:
  program counter:   1893
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], ?thegame["team1"]]

Step 2530:
  program counter:   1894
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 2, 4 })
  start expression:  line=59 column=27
  end expression:    line=59 column=34
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], { 2, 4 }]

Step 2531:
  program counter:   1895
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ 2, 4 }, []); insert first value into the second; push result ([{ 2, 4 }])
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 4 } ]]

Step 2532:
  program counter:   1896
  hvm code:          LoadVar id
  explanation:       push value (2) of variable "id"
  source code:       g->team1 = remove(g->team1, id)
                                                 ^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 4 } ], 2]

Step 2533:
  program counter:   1897
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=59 column=37
  end expression:    line=59 column=38
  method variables:  { g: ?thegame }

Step 2534:
  program counter:   1898
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [{ 2, 4 }]); insert first value into the second; push result ([{ 2, 4 }, 2])
  source code:       g->team1 = remove(g->team1, id)
                                       ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [ { 2, 4 }, 2 ]]

Step 2535:
  program counter:   1899
  hvm code:          Apply PC(1306)
  explanation:       pop an argument ([{ 2, 4 }, 2]) and call method (1306: "remove")
  source code:       g->team1 = remove(g->team1, id)
                                ^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_leave(?thegame, 2) --> remove({ 2, 4 }, 2)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, [ { 2, 4 }, 2 ]]

Step 2536:
  program counter:   1306
  hvm code:          Frame remove(s, elt)
  explanation:       pop argument ([{ 2, 4 }, 2]), assign to (s, elt), and run method "remove"
  module:            set
  start statement:   line=24 column=1
  end statement:     line=24 column=34
  source code:       def remove(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { elt: 2, s: { 2, 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }]

Step 2537:
  program counter:   1307
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=22
  source code:       result = s - {elt}
                              ^

Step 2538:
  program counter:   1308
  hvm code:          LoadVar s
  explanation:       push value ({ 2, 4 }) of variable "s"
  start expression:  line=25 column=14
  end expression:    line=25 column=14
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 4 }]

Step 2539:
  program counter:   1309
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=25 column=14
  end expression:    line=25 column=14
  method variables:  { elt: 2 }

Step 2540:
  program counter:   1310
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       result = s - {elt}
                                   ^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 4 }, {}]

Step 2541:
  program counter:   1311
  hvm code:          LoadVar elt
  explanation:       push value (2) of variable "elt"
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 4 }, {}, 2]

Step 2542:
  program counter:   1312
  hvm code:          DelVar elt
  explanation:       delete method variable elt
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  method variables:  { }

Step 2543:
  program counter:   1313
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (2, {}); insert first value into the second; push result ({ 2 })
  start expression:  line=25 column=19
  end expression:    line=25 column=21
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 2, 4 }, { 2 }]

Step 2544:
  program counter:   1314
  hvm code:          2-ary -
  explanation:       pop 2 values ({ 2 }, { 2, 4 }); the second integer minus the first; push result ({ 4 })
  source code:       result = s - {elt}
                              ^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }, { 4 }]

Step 2545:
  program counter:   1315
  hvm code:          StoreVar result
  explanation:       pop value ({ 4 }) and store locally in variable \"result\"
  source code:       result = s - {elt}
                     ^^^^^^^^
  method variables:  { result: { 4 } }
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], [], 30386, { "g": ?thegame }]

Step 2546:
  program counter:   1316
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=24 column=1
  end statement:     line=24 column=34
  source code:       def remove(s, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"], { 4 }]

Step 2547:
  program counter:   1900
  hvm code:          Store
  explanation:       pop value ({ 4 }) and address (?thegame["team1"]) and store
  module:            game
  start statement:   line=59 column=9
  end statement:     line=59 column=39
  source code:       g->team1 = remove(g->team1, id)
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 4 }, "team2": { 2, 3 }, "waiting": [] } }
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}]

Step 2548:
  program counter:   1901
  hvm code:          Jump 1936
  explanation:       set program counter to 1936
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                     ^^^^^^^^^^^^^^^^^^

Step 2549:
  program counter:   1936
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=66 column=5
  end statement:     line=66 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^

Step 2550:
  program counter:   1937
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start expression:  line=66 column=13
  end expression:    line=66 column=13
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2551:
  program counter:   1938
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2552:
  program counter:   1939
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2553:
  program counter:   1940
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 4 })
  start expression:  line=66 column=13
  end expression:    line=66 column=20
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}, { 4 }]

Step 2554:
  program counter:   1941
  hvm code:          1-ary len
  explanation:       pop a value ({ 4 }); compute cardinality; push result (1)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 1]

Step 2555:
  program counter:   1942
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31954, {:}, 1, 0]

Step 2556:
  program counter:   1943
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 1); check if both values are the same; push result (False)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2557:
  program counter:   1944
  hvm code:          JumpCond False 1953
  explanation:       pop value (False), compare to False, and jump to 1953 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2558:
  program counter:   1953
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=66 column=8
  end expression:    line=66 column=52
  stack:             [{:}, [], 31954, {:}, False]

Step 2559:
  program counter:   1954
  hvm code:          JumpCond False 1960
  explanation:       pop value (False), compare to False, and jump to 1960 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2560:
  program counter:   1960
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2561:
  program counter:   1961
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=69 column=14
  end expression:    line=69 column=14
  method variables:  { }

Step 2562:
  program counter:   1962
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2563:
  program counter:   1963
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2564:
  program counter:   1964
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_leave(?thegame, 2) --> release(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 31426, ?thegame["lock"]]

Step 2565:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2566:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(2) --> game_leave(?thegame, 2) --> release(?thegame["lock"])

Step 2567:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2568:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2569:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2570:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, True]

Step 2571:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2572:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2573:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2574:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2575:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 2576:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"], False]

Step 2577:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2578:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 2579:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2) --> game_leave(?thegame, 2)
  stack:             [{:}, [], 31954, {:}, None]

Step 2580:
  program counter:   1965
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2581:
  program counter:   1966
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(2)
  stack:             [{:}, None]

Step 2582:
  program counter:   1998
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 2583:
  program counter:   1999
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Running thread T6: player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])
method variables:
  binsema: ?thegame["lock"]
mode:  runnable
stack: ['{:}', '[]', '31954', '{:}', '[]', '30050', '{ "g": ?thegame, "id": 5 }']
other threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1999 terminated player(2)
  T4: pc=1999 terminated player(3)
  T5: pc=1999 terminated player(4)
  T7: pc=1999 terminated player(6)
shared variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 4 }, "team2": { 2, 3 }, "waiting": [] }
state id: 6722835
================================================

Step 2584:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  module:            synch
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(5) --> game_leave(?thegame, 5) --> acquire(?thegame["lock"])

Step 2585:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 2586:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 2587:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }, False]

Step 2588:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }, True]

Step 2589:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }]

Step 2590:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 2591:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2592:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 2593:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 2594:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }, ?thegame["lock"], True]

Step 2595:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 30050, { "g": ?thegame, "id": 5 }]

Step 2596:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 2597:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  call trace:        player(5) --> game_leave(?thegame, 5)
  stack:             [{:}, [], 31954, {:}, None]

Step 2598:
  program counter:   1879
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=55 column=5
  end statement:     line=55 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2599:
  program counter:   1880
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  start statement:   line=58 column=5
  end statement:     line=58 column=22
  source code:       if id in g->team1:
                        ^^
  stack:             [{:}, [], 31954, {:}, 5]

Step 2600:
  program counter:   1881
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if id in g->team1:
                              ^
  stack:             [{:}, [], 31954, {:}, 5, ?thegame]

Step 2601:
  program counter:   1882
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if id in g->team1:
                                 ^^^^^
  stack:             [{:}, [], 31954, {:}, 5, ?thegame, "team1"]

Step 2602:
  program counter:   1883
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if id in g->team1:
                              ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 5, ?thegame["team1"]]

Step 2603:
  program counter:   1884
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 4 })
  start expression:  line=58 column=14
  end expression:    line=58 column=21
  call trace:        player(5) --> game_leave(?thegame, 5)
  stack:             [{:}, [], 31954, {:}, 5, { 4 }]

Step 2604:
  program counter:   1885
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 4 }, 5); check if the second value is a member of the first; push result (False)
  source code:       if id in g->team1:
                        ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2605:
  program counter:   1886
  hvm code:          JumpCond False 1902
  explanation:       pop value (False), compare to False, and jump to 1902 if the same
  source code:       if id in g->team1:
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2606:
  program counter:   1902
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  start statement:   line=60 column=5
  end statement:     line=60 column=24
  source code:       elif id in g->team2:
                          ^^
  stack:             [{:}, [], 31954, {:}, 5]

Step 2607:
  program counter:   1903
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       elif id in g->team2:
                                ^
  stack:             [{:}, [], 31954, {:}, 5, ?thegame]

Step 2608:
  program counter:   1904
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       elif id in g->team2:
                                   ^^^^^
  stack:             [{:}, [], 31954, {:}, 5, ?thegame, "team2"]

Step 2609:
  program counter:   1905
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       elif id in g->team2:
                                ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 5, ?thegame["team2"]]

Step 2610:
  program counter:   1906
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({ 2, 3 })
  start expression:  line=60 column=16
  end expression:    line=60 column=23
  call trace:        player(5) --> game_leave(?thegame, 5)
  stack:             [{:}, [], 31954, {:}, 5, { 2, 3 }]

Step 2611:
  program counter:   1907
  hvm code:          2-ary in
  explanation:       pop 2 values ({ 2, 3 }, 5); check if the second value is a member of the first; push result (False)
  source code:       elif id in g->team2:
                          ^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2612:
  program counter:   1908
  hvm code:          JumpCond False 1936
  explanation:       pop value (False), compare to False, and jump to 1936 if the same
  source code:       elif id in g->team2:
                     ^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2613:
  program counter:   1936
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=66 column=5
  end statement:     line=66 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  method variables:  { g: ?thegame }

Step 2614:
  program counter:   1937
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start expression:  line=66 column=13
  end expression:    line=66 column=13
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2615:
  program counter:   1938
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "team1"]

Step 2616:
  program counter:   1939
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["team1"]]

Step 2617:
  program counter:   1940
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({ 4 })
  start expression:  line=66 column=13
  end expression:    line=66 column=20
  call trace:        player(5) --> game_leave(?thegame, 5)
  stack:             [{:}, [], 31954, {:}, { 4 }]

Step 2618:
  program counter:   1941
  hvm code:          1-ary len
  explanation:       pop a value ({ 4 }); compute cardinality; push result (1)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, 1]

Step 2619:
  program counter:   1942
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 31954, {:}, 1, 0]

Step 2620:
  program counter:   1943
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 1); check if both values are the same; push result (False)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}, False]

Step 2621:
  program counter:   1944
  hvm code:          JumpCond False 1953
  explanation:       pop value (False), compare to False, and jump to 1953 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2622:
  program counter:   1953
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=66 column=8
  end expression:    line=66 column=52
  stack:             [{:}, [], 31954, {:}, False]

Step 2623:
  program counter:   1954
  hvm code:          JumpCond False 1960
  explanation:       pop value (False), compare to False, and jump to 1960 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 31954, {:}]

Step 2624:
  program counter:   1960
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                              ^
  stack:             [{:}, [], 31954, {:}, ?thegame]

Step 2625:
  program counter:   1961
  hvm code:          DelVar g
  explanation:       delete method variable g
  start expression:  line=69 column=14
  end expression:    line=69 column=14
  method variables:  { }

Step 2626:
  program counter:   1962
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame, "lock"]

Step 2627:
  program counter:   1963
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       release(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 31954, {:}, ?thegame["lock"]]

Step 2628:
  program counter:   1964
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?thegame["lock"]) and call method (973: "release")
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_leave(?thegame, 5) --> release(?thegame["lock"])
  stack:             [{:}, [], 31954, {:}, [], 31426, ?thegame["lock"]]

Step 2629:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2630:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(5) --> game_leave(?thegame, 5) --> release(?thegame["lock"])

Step 2631:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2632:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2633:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2634:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, True]

Step 2635:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2636:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 2637:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 2638:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"]]

Step 2639:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 2640:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}, ?thegame["lock"], False]

Step 2641:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 4 }, "team2": { 2, 3 }, "waiting": [] } }
  stack:             [{:}, [], 31954, {:}, [], 31426, {:}]

Step 2642:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 2643:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_leave(?thegame, 5)
  stack:             [{:}, [], 31954, {:}, None]

Step 2644:
  program counter:   1965
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=69 column=5
  end statement:     line=69 column=21
  source code:       release(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 31954, {:}]

Step 2645:
  program counter:   1966
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=54 column=1
  end statement:     line=54 column=22
  source code:       def game_leave(g, id):
                     ^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5)
  stack:             [{:}, None]

Step 2646:
  program counter:   1998
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=9 column=5
  end statement:     line=9 column=30
  source code:       game_leave(?thegame, self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 2647:
  program counter:   1999
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=5 column=1
  end statement:     line=5 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Final state
================================================
Threads:
  T0: pc=2019 terminated atomic __init__()
  T1: pc=1032 blocked game_umpire(?thegame) --> wait(?thegame["active_game"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1999 terminated player(2)
  T4: pc=1999 terminated player(3)
  T5: pc=1999 terminated player(4)
  T6: pc=1999 terminated player(5)
  T7: pc=1999 terminated player(6)
Variables:
  thegame: { "active_game": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": { 4 }, "team2": { 2, 3 }, "waiting": [] }
