Issue: Safety violation

Modules:
  bag: C:\Python310\Lib\site-packages\harmony_model_checker\modules\bag.hny
  game: c:\Users\leeev\OneDrive\Desktop\Folders\SCHOOL\CS4410\hw6\game.hny
  __main__: c:\Users\leeev\OneDrive\Desktop\Folders\SCHOOL\CS4410\hw6\test.hny
  synch: C:\Python310\Lib\site-packages\harmony_model_checker\modules\synch.hny
  list: C:\Python310\Lib\site-packages\harmony_model_checker\modules\list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=19 column=26
  source code:       from game import *
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 54
  explanation:       jump over method definition: set program counter to 54
  module:            list
  start statement:   line=2 column=1
  end statement:     line=2 column=35
  source code:       def subseq(s, b, e) returns result:
                     ^^^

Step 3:
  program counter:   54
  hvm code:          Push PC(57)
  explanation:       push constant PC(57)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(57)]

Step 4:
  program counter:   55
  hvm code:          Builtin(list$tail)
  explanation:       pop pc () and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   56
  hvm code:          Jump 602
  explanation:       jump over method definition: set program counter to 602
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 6:
  program counter:   602
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(605)]

Step 7:
  program counter:   603
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc () and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   604
  hvm code:          Jump 624
  explanation:       jump over method definition: set program counter to 624
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 9:
  program counter:   624
  hvm code:          Push PC(627)
  explanation:       push constant PC(627)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(627)]

Step 10:
  program counter:   625
  hvm code:          Builtin(bag$size)
  explanation:       pop pc () and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   626
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 12:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(649)]

Step 13:
  program counter:   647
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc () and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   648
  hvm code:          Jump 665
  explanation:       jump over method definition: set program counter to 665
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 15:
  program counter:   665
  hvm code:          Push PC(668)
  explanation:       push constant PC(668)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(668)]

Step 16:
  program counter:   666
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc () and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   667
  hvm code:          Jump 693
  explanation:       jump over method definition: set program counter to 693
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 18:
  program counter:   693
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(696)]

Step 19:
  program counter:   694
  hvm code:          Builtin(bag$add)
  explanation:       pop pc () and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   695
  hvm code:          Jump 722
  explanation:       jump over method definition: set program counter to 722
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 21:
  program counter:   722
  hvm code:          Push PC(725)
  explanation:       push constant PC(725)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(725)]

Step 22:
  program counter:   723
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc () and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   724
  hvm code:          Jump 1576
  explanation:       jump over method definition: set program counter to 1576
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 24:
  program counter:   1576
  hvm code:          Push ()
  explanation:       push constant ()
  module:            __main__
  start statement:   line=4 column=1
  end statement:     line=4 column=16
  source code:       thegame = Game()
                                   ^^
  stack:             [{:}, []]

Step 25:
  program counter:   1577
  hvm code:          Apply PC(1206)
  explanation:       pop an argument ([]) and call method (1206: "Game")
  source code:       thegame = Game()
                               ^^^^^^
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 25234, []]

Step 26:
  program counter:   1206
  hvm code:          Frame Game()
  explanation:       pop argument () and run method "Game"
  module:            game
  start statement:   line=4 column=1
  end statement:     line=4 column=24
  source code:       def Game() returns game:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}]

Step 27:
  program counter:   1207
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, {:}]

Step 28:
  program counter:   1208
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, {:}, "waiting"]

Step 29:
  program counter:   1209
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, {:}, "waiting", []]

Step 30:
  program counter:   1210
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([], "waiting", {:}); add key/value pair to dictionary; push result ({ "waiting": [] })
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "waiting": [] }]

Step 31:
  program counter:   1211
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "waiting": [] }, "team1"]

Step 32:
  program counter:   1212
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "waiting": [] }, "team1", {}]

Step 33:
  program counter:   1213
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({}, "team1", { "waiting": [] }); add key/value pair to dictionary; push result ({ "team1": {}, "waiting": [] })
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "waiting": [] }]

Step 34:
  program counter:   1214
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "waiting": [] }, "team2"]

Step 35:
  program counter:   1215
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "waiting": [] }, "team2", {}]

Step 36:
  program counter:   1216
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({}, "team2", { "team1": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "team1": {}, "team2": {}, "waiting": [] })
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }]

Step 37:
  program counter:   1217
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock"]

Step 38:
  program counter:   1218
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", []]

Step 39:
  program counter:   1219
  hvm code:          Apply PC(931)
  explanation:       pop an argument ([]) and call method (931: "Lock")
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  call trace:        __init__() --> Game() --> Lock()
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, []]

Step 40:
  program counter:   931
  hvm code:          Frame Lock()
  explanation:       pop argument () and run method "Lock"
  module:            synch
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}]

Step 41:
  program counter:   932
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                                      ^^^^^

Step 42:
  program counter:   933
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=26 column=22
  end expression:    line=26 column=26
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, False]

Step 43:
  program counter:   934
  hvm code:          Apply PC(912)
  explanation:       pop an argument (False) and call method (912: "BinSema")
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Game() --> Lock() --> BinSema(False)
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, False]

Step 44:
  program counter:   912
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (False), assign to initial, and run method "BinSema"
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: False }
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}]

Step 45:
  program counter:   913
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 46:
  program counter:   914
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 47:
  program counter:   915
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False]

Step 48:
  program counter:   916
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False, {}]

Step 49:
  program counter:   917
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False, {}, False]

Step 50:
  program counter:   918
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False, { False }]

Step 51:
  program counter:   919
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False, { False }, True]

Step 52:
  program counter:   920
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False, { False, True }]

Step 53:
  program counter:   921
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, False); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, True]

Step 54:
  program counter:   922
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}]

Step 55:
  program counter:   923
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 56:
  program counter:   924
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 57:
  program counter:   925
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}, False]

Step 58:
  program counter:   926
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 59:
  program counter:   927
  hvm code:          StoreVar sema
  explanation:       pop value (False) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: False }
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, [], 14946, {:}]

Step 60:
  program counter:   928
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game() --> Lock()
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}, False]

Step 61:
  program counter:   935
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable \"result\"
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", [], 19506, {:}]

Step 62:
  program counter:   936
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 25234, {:}, { "team1": {}, "team2": {}, "waiting": [] }, "lock", False]

Step 63:
  program counter:   1220
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "lock", { "team1": {}, "team2": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "lock": False, "team1": {}, "team2": {}, "waiting": [] })
  module:            game
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }]

Step 64:
  program counter:   1221
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game"]

Step 65:
  program counter:   1222
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", []]

Step 66:
  program counter:   1223
  hvm code:          Apply PC(989)
  explanation:       pop an argument ([]) and call method (989: "Condition")
  source code:       .active_game: Condition(), .players: Condition()}
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, []]

Step 67:
  program counter:   989
  hvm code:          Frame Condition()
  explanation:       pop argument () and run method "Condition"
  module:            synch
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}]

Step 68:
  program counter:   990
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^

Step 69:
  program counter:   991
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  start expression:  line=44 column=14
  end expression:    line=44 column=22
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, PC(541)]

Step 70:
  program counter:   992
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, PC(541), []]

Step 71:
  program counter:   993
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, ?PC(541)[[]]]

Step 72:
  program counter:   994
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=44 column=14
  end expression:    line=44 column=24
  call trace:        __init__() --> Game() --> Condition() --> empty()
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, [], 15906, []]

Step 73:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, [], 15906, {:}]

Step 74:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, [], 15906, {:}, {:}]

Step 75:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, [], 15906, {:}]

Step 76:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}, {:}]

Step 77:
  program counter:   995
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable \"result\"
  module:            synch
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", [], 19570, {:}]

Step 78:
  program counter:   996
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 25234, {:}, { "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "active_game", {:}]

Step 79:
  program counter:   1224
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "active_game", { "lock": False, "team1": {}, "team2": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] })
  module:            game
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }]

Step 80:
  program counter:   1225
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players"]

Step 81:
  program counter:   1226
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .active_game: Condition(), .players: Condition()}
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", []]

Step 82:
  program counter:   1227
  hvm code:          Apply PC(989)
  explanation:       pop an argument ([]) and call method (989: "Condition")
  source code:       .active_game: Condition(), .players: Condition()}
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, []]

Step 83:
  program counter:   989
  hvm code:          Frame Condition()
  explanation:       pop argument () and run method "Condition"
  module:            synch
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}]

Step 84:
  program counter:   990
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^

Step 85:
  program counter:   991
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  start expression:  line=44 column=14
  end expression:    line=44 column=22
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, PC(541)]

Step 86:
  program counter:   992
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, PC(541), []]

Step 87:
  program counter:   993
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, ?PC(541)[[]]]

Step 88:
  program counter:   994
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=44 column=14
  end expression:    line=44 column=24
  call trace:        __init__() --> Game() --> Condition() --> empty()
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, [], 15906, []]

Step 89:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, [], 15906, {:}]

Step 90:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, [], 15906, {:}, {:}]

Step 91:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, [], 15906, {:}]

Step 92:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game() --> Condition()
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}, {:}]

Step 93:
  program counter:   995
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable \"result\"
  module:            synch
  start statement:   line=44 column=5
  end statement:     line=44 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", [], 19634, {:}]

Step 94:
  program counter:   996
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=43 column=1
  end statement:     line=43 column=31
  source code:       def Condition() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Game()
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }, "players", {:}]

Step 95:
  program counter:   1228
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "players", { "active_game": {:}, "lock": False, "team1": {}, "team2": {}, "waiting": [] }); add key/value pair to dictionary; push result ({ "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] })
  module:            game
  start statement:   line=5 column=5
  end statement:     line=6 column=61
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  stack:             [{:}, [], 25234, {:}, { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }]

Step 96:
  program counter:   1229
  hvm code:          StoreVar game
  explanation:       pop value ({ "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }) and store locally in variable \"game\"
  source code:       game = { .waiting: [], .team1: {}, .team2: {}, .lock: Lock(), 
  method variables:  { game: { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] } }
  stack:             [{:}, [], 25234, {:}]

Step 97:
  program counter:   1230
  hvm code:          ReturnOp(game)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=4 column=1
  end statement:     line=4 column=24
  source code:       def Game() returns game:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__()
  stack:             [{:}, { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }]

Step 98:
  program counter:   1578
  hvm code:          Store thegame
  explanation:       pop value ({ "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }) and store into variable thegame
  module:            __main__
  start statement:   line=4 column=1
  end statement:     line=4 column=16
  source code:       thegame = Game()
                     ^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] } }
  stack:             [{:}]

Step 99:
  program counter:   1579
  hvm code:          Jump 1609
  explanation:       jump over method definition: set program counter to 1609
  start statement:   line=6 column=1
  end statement:     line=6 column=17
  source code:       def player(self):
                     ^^^

Step 100:
  program counter:   1609
  hvm code:          Push ?PC(1233)
  explanation:       push constant ?PC(1233)
  start statement:   line=16 column=1
  end statement:     line=16 column=35
  source code:       spawn eternal game_umpire(?thegame)
                                   ^^^^^^^^^^^
  stack:             [{:}, ?PC(1233)]

Step 101:
  program counter:   1610
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       spawn eternal game_umpire(?thegame)
                                                ^^^^^^^
  stack:             [{:}, ?PC(1233), ?thegame]

Step 102:
  program counter:   1611
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (?thegame, ?PC(1233)); push result (?PC(1233)[?thegame])
  source code:       spawn eternal game_umpire(?thegame)
                                   ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1233)[?thegame]]

Step 103:
  program counter:   1612
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn eternal game_umpire(?thegame)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1233)[?thegame], {:}]

Step 104:
  program counter:   1613
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (?thegame), and pc (1233: "game_umpire"), and spawn thread
  start expression:  line=16 column=1
  end expression:    line=16 column=35
  stack:             [{:}]

Step 105:
  program counter:   1614
  hvm code:          Push 1
  explanation:       push constant 1
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                 ^
  stack:             [{:}, 1]

Step 106:
  program counter:   1615
  hvm code:          Push 6
  explanation:       push constant 6
  source code:       for id in { 1 .. NPLAYERS }:
                                      ^^^^^^^^
  stack:             [{:}, 1, 6]

Step 107:
  program counter:   1616
  hvm code:          2-ary ..
  explanation:       pop 2 values (6, 1); range of integers; push result ({ 1, 2, 3, 4, 5, 6 })
  source code:       for id in { 1 .. NPLAYERS }:
                                 ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }]

Step 108:
  program counter:   1617
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 0]

Step 109:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (0) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (1) to id; push new index (1) and True
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  method variables:  { id: 1 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, True]

Step 110:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (True), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1]

Step 111:
  program counter:   1620
  hvm code:          Push ?PC(1580)
  explanation:       push constant ?PC(1580)
  start statement:   line=19 column=5
  end statement:     line=19 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1580)]

Step 112:
  program counter:   1621
  hvm code:          LoadVar id
  explanation:       push value (1) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1580), 1]

Step 113:
  program counter:   1622
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=19 column=18
  end expression:    line=19 column=19
  method variables:  { }

Step 114:
  program counter:   1623
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1580)); push result (?PC(1580)[1])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1580)[1]]

Step 115:
  program counter:   1624
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1, ?PC(1580)[1], {:}]

Step 116:
  program counter:   1625
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1580: "player"), and spawn thread
  start expression:  line=19 column=5
  end expression:    line=19 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 1]

Step 117:
  program counter:   1626
  hvm code:          Jump 1618
  explanation:       set program counter to 1618
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                               ^

Step 118:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (1) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (2) to id; push new index (2) and True
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  method variables:  { id: 2 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, True]

Step 119:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (True), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2]

Step 120:
  program counter:   1620
  hvm code:          Push ?PC(1580)
  explanation:       push constant ?PC(1580)
  start statement:   line=19 column=5
  end statement:     line=19 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1580)]

Step 121:
  program counter:   1621
  hvm code:          LoadVar id
  explanation:       push value (2) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1580), 2]

Step 122:
  program counter:   1622
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=19 column=18
  end expression:    line=19 column=19
  method variables:  { }

Step 123:
  program counter:   1623
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (2, ?PC(1580)); push result (?PC(1580)[2])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1580)[2]]

Step 124:
  program counter:   1624
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2, ?PC(1580)[2], {:}]

Step 125:
  program counter:   1625
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (2), and pc (1580: "player"), and spawn thread
  start expression:  line=19 column=5
  end expression:    line=19 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 2]

Step 126:
  program counter:   1626
  hvm code:          Jump 1618
  explanation:       set program counter to 1618
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                               ^

Step 127:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (2) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (3) to id; push new index (3) and True
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  method variables:  { id: 3 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, True]

Step 128:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (True), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3]

Step 129:
  program counter:   1620
  hvm code:          Push ?PC(1580)
  explanation:       push constant ?PC(1580)
  start statement:   line=19 column=5
  end statement:     line=19 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1580)]

Step 130:
  program counter:   1621
  hvm code:          LoadVar id
  explanation:       push value (3) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1580), 3]

Step 131:
  program counter:   1622
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=19 column=18
  end expression:    line=19 column=19
  method variables:  { }

Step 132:
  program counter:   1623
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (3, ?PC(1580)); push result (?PC(1580)[3])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1580)[3]]

Step 133:
  program counter:   1624
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3, ?PC(1580)[3], {:}]

Step 134:
  program counter:   1625
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (3), and pc (1580: "player"), and spawn thread
  start expression:  line=19 column=5
  end expression:    line=19 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 3]

Step 135:
  program counter:   1626
  hvm code:          Jump 1618
  explanation:       set program counter to 1618
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                               ^

Step 136:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (3) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (4) to id; push new index (4) and True
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  method variables:  { id: 4 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, True]

Step 137:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (True), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4]

Step 138:
  program counter:   1620
  hvm code:          Push ?PC(1580)
  explanation:       push constant ?PC(1580)
  start statement:   line=19 column=5
  end statement:     line=19 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1580)]

Step 139:
  program counter:   1621
  hvm code:          LoadVar id
  explanation:       push value (4) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1580), 4]

Step 140:
  program counter:   1622
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=19 column=18
  end expression:    line=19 column=19
  method variables:  { }

Step 141:
  program counter:   1623
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (4, ?PC(1580)); push result (?PC(1580)[4])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1580)[4]]

Step 142:
  program counter:   1624
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4, ?PC(1580)[4], {:}]

Step 143:
  program counter:   1625
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (4), and pc (1580: "player"), and spawn thread
  start expression:  line=19 column=5
  end expression:    line=19 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 4]

Step 144:
  program counter:   1626
  hvm code:          Jump 1618
  explanation:       set program counter to 1618
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                               ^

Step 145:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (4) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (5) to id; push new index (5) and True
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  method variables:  { id: 5 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, True]

Step 146:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (True), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5]

Step 147:
  program counter:   1620
  hvm code:          Push ?PC(1580)
  explanation:       push constant ?PC(1580)
  start statement:   line=19 column=5
  end statement:     line=19 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1580)]

Step 148:
  program counter:   1621
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1580), 5]

Step 149:
  program counter:   1622
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=19 column=18
  end expression:    line=19 column=19
  method variables:  { }

Step 150:
  program counter:   1623
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (5, ?PC(1580)); push result (?PC(1580)[5])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1580)[5]]

Step 151:
  program counter:   1624
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5, ?PC(1580)[5], {:}]

Step 152:
  program counter:   1625
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (5), and pc (1580: "player"), and spawn thread
  start expression:  line=19 column=5
  end expression:    line=19 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 5]

Step 153:
  program counter:   1626
  hvm code:          Jump 1618
  explanation:       set program counter to 1618
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                               ^

Step 154:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (5) and value ({ 1, 2, 3, 4, 5, 6 }); assign value (6) to id; push new index (6) and True
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  method variables:  { id: 6 }
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, True]

Step 155:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (True), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6]

Step 156:
  program counter:   1620
  hvm code:          Push ?PC(1580)
  explanation:       push constant ?PC(1580)
  start statement:   line=19 column=5
  end statement:     line=19 column=20
  source code:       spawn player(id)
                           ^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1580)]

Step 157:
  program counter:   1621
  hvm code:          LoadVar id
  explanation:       push value (6) of variable "id"
  source code:       spawn player(id)
                                  ^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1580), 6]

Step 158:
  program counter:   1622
  hvm code:          DelVar id
  explanation:       delete method variable id
  start expression:  line=19 column=18
  end expression:    line=19 column=19
  method variables:  { }

Step 159:
  program counter:   1623
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (6, ?PC(1580)); push result (?PC(1580)[6])
  source code:       spawn player(id)
                           ^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1580)[6]]

Step 160:
  program counter:   1624
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn player(id)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6, ?PC(1580)[6], {:}]

Step 161:
  program counter:   1625
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (6), and pc (1580: "player"), and spawn thread
  start expression:  line=19 column=5
  end expression:    line=19 column=20
  stack:             [{:}, { 1, 2, 3, 4, 5, 6 }, 6]

Step 162:
  program counter:   1626
  hvm code:          Jump 1618
  explanation:       set program counter to 1618
  start statement:   line=18 column=1
  end statement:     line=18 column=27
  source code:       for id in { 1 .. NPLAYERS }:
                                               ^

Step 163:
  program counter:   1618
  hvm code:          Cut(id)
  explanation:       pop index (6) and value ({ 1, 2, 3, 4, 5, 6 }); out of range -> push False
  source code:       for id in { 1 .. NPLAYERS }:
                     ^^^
  stack:             [{:}, False]

Step 164:
  program counter:   1619
  hvm code:          JumpCond False 1627
  explanation:       pop value (False), compare to False, and jump to 1627 if the same
  start expression:  line=18 column=1
  end expression:    line=18 column=3
  stack:             [{:}]

Step 165:
  program counter:   1627
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=1 column=1
  end statement:     line=19 column=26
  source code:       from game import *

Step 166:
  program counter:   1628
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start expression:  line=1 column=1
  end expression:    line=19 column=26
  new mode:          terminated
  stack:             [None]

================================================
Running thread T2: player(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=1628 terminated atomic __init__()
  T1: pc=1233 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T3: pc=1580 runnable player(2)
    about to run method player with argument 2
  T4: pc=1580 runnable player(3)
    about to run method player with argument 3
  T5: pc=1580 runnable player(4)
    about to run method player with argument 4
  T6: pc=1580 runnable player(5)
    about to run method player with argument 5
  T7: pc=1580 runnable player(6)
    about to run method player with argument 6
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": {:}, "team1": {}, "team2": {}, "waiting": [] }
state id: 2
================================================

Step 167:
  program counter:   1580
  hvm code:          Frame player(self)
  explanation:       pop argument (1), assign to self, and run method "player"
  start statement:   line=6 column=1
  end statement:     line=6 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        player(1)
  stack:             [{:}]

Step 168:
  program counter:   1581
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=8 column=5
  end statement:     line=8 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 169:
  program counter:   1582
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 170:
  program counter:   1583
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 171:
  program counter:   1584
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 1]

Step 172:
  program counter:   1585
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?thegame]); insert first value into the second; push result ([?thegame, 1])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 1 ]]

Step 173:
  program counter:   1586
  hvm code:          Apply PC(1377)
  explanation:       pop an argument ([?thegame, 1]) and call method (1377: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, [ ?thegame, 1 ]]

Step 174:
  program counter:   1377
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 1]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=33 column=1
  end statement:     line=33 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 175:
  program counter:   1378
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=34 column=5
  end statement:     line=34 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame]

Step 176:
  program counter:   1379
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame, "lock"]

Step 177:
  program counter:   1380
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["lock"]]

Step 178:
  program counter:   1381
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, ?thegame["lock"]]

Step 179:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }]

Step 180:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(1) --> game_join(?thegame, 1) --> acquire(?thegame["lock"])

Step 181:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 182:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 183:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }, False]

Step 184:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }, True]

Step 185:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }]

Step 186:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 187:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 188:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 189:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 190:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }, ?thegame["lock"], True]

Step 191:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": {:}, "team1": {}, "team2": {}, "waiting": [] } }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22098, { "g": ?thegame, "id": 1 }]

Step 192:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 193:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }, None]

Step 194:
  program counter:   1382
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=34 column=5
  end statement:     line=34 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 195:
  program counter:   1383
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame]

Step 196:
  program counter:   1384
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame, "waiting"]

Step 197:
  program counter:   1385
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"]]

Step 198:
  program counter:   1386
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], ?thegame]

Step 199:
  program counter:   1387
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 200:
  program counter:   1388
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 201:
  program counter:   1389
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([])
  start expression:  line=36 column=18
  end expression:    line=36 column=27
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], []]

Step 202:
  program counter:   1390
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], [], []]

Step 203:
  program counter:   1391
  hvm code:          LoadVar id
  explanation:       push value (1) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], [], [], 1]

Step 204:
  program counter:   1392
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], [], [ 1 ]]

Step 205:
  program counter:   1393
  hvm code:          2-ary +
  explanation:       pop 2 values ([1], []); concatenate the lists; push result ([1])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["waiting"], [ 1 ]]

Step 206:
  program counter:   1394
  hvm code:          Store
  explanation:       pop value ([1]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": {:}, "team1": {}, "team2": {}, "waiting": [ 1 ] } }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 207:
  program counter:   1395
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=39 column=5
  end statement:     line=39 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame]

Step 208:
  program counter:   1396
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame, "team1"]

Step 209:
  program counter:   1397
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["team1"]]

Step 210:
  program counter:   1398
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=39 column=13
  end expression:    line=39 column=20
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }, {}]

Step 211:
  program counter:   1399
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, 0]

Step 212:
  program counter:   1400
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 25378, { "self": 1 }, 0, 0]

Step 213:
  program counter:   1401
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, True]

Step 214:
  program counter:   1402
  hvm code:          JumpCond False 1411
  explanation:       pop value (True), compare to False, and jump to 1411 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 215:
  program counter:   1403
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame]

Step 216:
  program counter:   1404
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame, "team2"]

Step 217:
  program counter:   1405
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["team2"]]

Step 218:
  program counter:   1406
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=39 column=38
  end expression:    line=39 column=45
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }, {}]

Step 219:
  program counter:   1407
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, 0]

Step 220:
  program counter:   1408
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 25378, { "self": 1 }, 0, 0]

Step 221:
  program counter:   1409
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, True]

Step 222:
  program counter:   1410
  hvm code:          Jump 1412
  explanation:       set program counter to 1412
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 223:
  program counter:   1412
  hvm code:          JumpCond False 1418
  explanation:       pop value (True), compare to False, and jump to 1418 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 224:
  program counter:   1413
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=40 column=9
  end statement:     line=40 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame]

Step 225:
  program counter:   1414
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame, "active_game"]

Step 226:
  program counter:   1415
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["active_game"]]

Step 227:
  program counter:   1416
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, ?thegame["active_game"]]

Step 228:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }]

Step 229:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"])

Step 230:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, ?thegame["active_game"]]

Step 231:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}]

Step 232:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, PC(541)]

Step 233:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, PC(541), []]

Step 234:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, ?PC(541)[[]]]

Step 235:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, [], 17186, []]

Step 236:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 237:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 238:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 239:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(1) --> game_join(?thegame, 1) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, {:}, {:}]

Step 240:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }, False]

Step 241:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 22658, { "g": ?thegame, "id": 1 }]

Step 242:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 243:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 244:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 1 }
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }, None]

Step 245:
  program counter:   1417
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=40 column=9
  end statement:     line=40 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 246:
  program counter:   1418
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=44 column=5
  end statement:     line=44 column=118
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame]

Step 247:
  program counter:   1419
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame, "team1"]

Step 248:
  program counter:   1420
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, ?thegame["team1"]]

Step 249:
  program counter:   1421
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=44 column=16
  end expression:    line=44 column=23
  call trace:        player(1) --> game_join(?thegame, 1)
  stack:             [{:}, [], 25378, { "self": 1 }, {}]

Step 250:
  program counter:   1422
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, 0]

Step 251:
  program counter:   1423
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                             ^
  stack:             [{:}, [], 25378, { "self": 1 }, 0, 0]

Step 252:
  program counter:   1424
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, True]

Step 253:
  program counter:   1425
  hvm code:          JumpCond True 1456
  explanation:       pop value (True), compare to True, and jump to 1456 if the same
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 254:
  program counter:   1456
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=44 column=11
  end expression:    line=44 column=117
  stack:             [{:}, [], 25378, { "self": 1 }, True]

Step 255:
  program counter:   1457
  hvm code:          JumpCond False 1470
  explanation:       pop value (True), compare to False, and jump to 1470 if the same
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }]

Step 256:
  program counter:   1458
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=45 column=9
  end statement:     line=45 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, []]

Step 257:
  program counter:   1459
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 25378, { "self": 1 }, [], ?thegame]

Step 258:
  program counter:   1460
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], ?thegame, "players"]

Step 259:
  program counter:   1461
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], ?thegame["players"]]

Step 260:
  program counter:   1462
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [ ?thegame["players"] ]]

Step 261:
  program counter:   1463
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 25378, { "self": 1 }, [ ?thegame["players"] ], ?thegame]

Step 262:
  program counter:   1464
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 263:
  program counter:   1465
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 264:
  program counter:   1466
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 265:
  program counter:   1467
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, [ ?thegame["players"], ?thegame["lock"] ]]

Step 266:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }]

Step 267:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, 0]

Step 268:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }]

Step 269:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 270:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, []]

Step 271:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 272:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 273:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }]

Step 274:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])

Step 275:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605)]

Step 276:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605), []]

Step 277:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605), [], ?thegame["players"]]

Step 278:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605), [], {:}]

Step 279:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605), [ {:} ]]

Step 280:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 281:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, PC(605), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 282:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])], PC(605)); push result (?PC(605)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?PC(605)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 283:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, [], 16242, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 284:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, 0]

Step 285:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }]

Step 286:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"]]

Step 287:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696)]

Step 288:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), []]

Step 289:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 290:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({:})
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [], {:}]

Step 291:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({:}, []); insert first value into the second; push result ([{:}])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ {:} ]]

Step 292:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ {:} ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 293:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]), [{:}]); insert first value into the second; push result ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], PC(696), [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 294:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])], PC(696)); push result (?PC(696)[[{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], ?PC(696)[[ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 295:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"]) --> add({:}, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]))
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], [], 16418, [ {:}, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 296:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 297:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1 ] } }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }]

Step 298:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["lock"]]

Step 299:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }, ?thegame["lock"], False]

Step 300:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1 ] } }
  stack:             [{:}, [], 25378, { "self": 1 }, [], 23474, { "g": ?thegame, "id": 1 }]

Step 301:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T6: player(5)
mode:  runnable
stack: ['5']
other threads:
  T0: pc=1628 terminated atomic __init__()
  T1: pc=1233 runnable game_umpire(?thegame)
    about to run method game_umpire with argument ?thegame
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1580 runnable player(2)
    about to run method player with argument 2
  T4: pc=1580 runnable player(3)
    about to run method player with argument 3
  T5: pc=1580 runnable player(4)
    about to run method player with argument 4
  T7: pc=1580 runnable player(6)
    about to run method player with argument 6
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1 ] }
state id: 2941
================================================

Step 302:
  program counter:   1580
  hvm code:          Frame player(self)
  explanation:       pop argument (5), assign to self, and run method "player"
  module:            __main__
  start statement:   line=6 column=1
  end statement:     line=6 column=17
  source code:       def player(self):
                     ^^^^^^^^^^^^^^^^^
  method variables:  { self: 5 }
  call trace:        player(5)
  stack:             [{:}]

Step 303:
  program counter:   1581
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=8 column=5
  end statement:     line=8 column=50
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 304:
  program counter:   1582
  hvm code:          Push ?thegame
  explanation:       push constant ?thegame
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                     ^^^^^^^
  stack:             [{:}, [], ?thegame]

Step 305:
  program counter:   1583
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame, []); insert first value into the second; push result ([?thegame])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame ]]

Step 306:
  program counter:   1584
  hvm code:          LoadVar self
  explanation:       push value (5) of variable "self"
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                              ^^^^
  stack:             [{:}, [ ?thegame ], 5]

Step 307:
  program counter:   1585
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (5, [?thegame]); insert first value into the second; push result ([?thegame, 5])
  source code:       let (team1, team2) = game_join(?thegame, self):
                                                    ^^^^^^^^^^^^^^
  stack:             [{:}, [ ?thegame, 5 ]]

Step 308:
  program counter:   1586
  hvm code:          Apply PC(1377)
  explanation:       pop an argument ([?thegame, 5]) and call method (1377: "game_join")
  source code:       let (team1, team2) = game_join(?thegame, self):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, [ ?thegame, 5 ]]

Step 309:
  program counter:   1377
  hvm code:          Frame game_join(g, id)
  explanation:       pop argument ([?thegame, 5]), assign to (g, id), and run method "game_join"
  module:            game
  start statement:   line=33 column=1
  end statement:     line=33 column=35
  source code:       def game_join(g, id) returns teams:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 310:
  program counter:   1378
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=34 column=5
  end statement:     line=34 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame]

Step 311:
  program counter:   1379
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame, "lock"]

Step 312:
  program counter:   1380
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["lock"]]

Step 313:
  program counter:   1381
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, ?thegame["lock"]]

Step 314:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }]

Step 315:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        player(5) --> game_join(?thegame, 5) --> acquire(?thegame["lock"])

Step 316:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 317:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 318:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }, False]

Step 319:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }, True]

Step 320:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }]

Step 321:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 322:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 323:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 324:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 325:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }, ?thegame["lock"], True]

Step 326:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1 ] } }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22098, { "g": ?thegame, "id": 5 }]

Step 327:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 328:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }, None]

Step 329:
  program counter:   1382
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=34 column=5
  end statement:     line=34 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 330:
  program counter:   1383
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=36 column=5
  end statement:     line=36 column=35
  source code:       g->waiting = g->waiting + [id,]
                     ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame]

Step 331:
  program counter:   1384
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                        ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame, "waiting"]

Step 332:
  program counter:   1385
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"]]

Step 333:
  program counter:   1386
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       g->waiting = g->waiting + [id,]
                                  ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], ?thegame]

Step 334:
  program counter:   1387
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       g->waiting = g->waiting + [id,]
                                     ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], ?thegame, "waiting"]

Step 335:
  program counter:   1388
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], ?thegame["waiting"]]

Step 336:
  program counter:   1389
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([1])
  start expression:  line=36 column=18
  end expression:    line=36 column=27
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], [ 1 ]]

Step 337:
  program counter:   1390
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], [ 1 ], []]

Step 338:
  program counter:   1391
  hvm code:          LoadVar id
  explanation:       push value (5) of variable "id"
  source code:       g->waiting = g->waiting + [id,]
                                                ^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], [ 1 ], [], 5]

Step 339:
  program counter:   1392
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (5, []); insert first value into the second; push result ([5])
  source code:       g->waiting = g->waiting + [id,]
                                                ^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], [ 1 ], [ 5 ]]

Step 340:
  program counter:   1393
  hvm code:          2-ary +
  explanation:       pop 2 values ([5], [1]); concatenate the lists; push result ([1, 5])
  source code:       g->waiting = g->waiting + [id,]
                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["waiting"], [ 1, 5 ]]

Step 341:
  program counter:   1394
  hvm code:          Store
  explanation:       pop value ([1, 5]) and address (?thegame["waiting"]) and store
  source code:       g->waiting = g->waiting + [id,]
                     ^^^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1, 5 ] } }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 342:
  program counter:   1395
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=39 column=5
  end statement:     line=39 column=53
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame]

Step 343:
  program counter:   1396
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                ^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame, "team1"]

Step 344:
  program counter:   1397
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                             ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["team1"]]

Step 345:
  program counter:   1398
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=39 column=13
  end expression:    line=39 column=20
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }, {}]

Step 346:
  program counter:   1399
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, 0]

Step 347:
  program counter:   1400
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                          ^
  stack:             [{:}, [], 25378, { "self": 5 }, 0, 0]

Step 348:
  program counter:   1401
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                         ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, True]

Step 349:
  program counter:   1402
  hvm code:          JumpCond False 1411
  explanation:       pop value (True), compare to False, and jump to 1411 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 350:
  program counter:   1403
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame]

Step 351:
  program counter:   1404
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                         ^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame, "team2"]

Step 352:
  program counter:   1405
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                      ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["team2"]]

Step 353:
  program counter:   1406
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=39 column=38
  end expression:    line=39 column=45
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }, {}]

Step 354:
  program counter:   1407
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, 0]

Step 355:
  program counter:   1408
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                                   ^
  stack:             [{:}, [], 25378, { "self": 5 }, 0, 0]

Step 356:
  program counter:   1409
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                                  ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, True]

Step 357:
  program counter:   1410
  hvm code:          Jump 1412
  explanation:       set program counter to 1412
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                                             ^^^

Step 358:
  program counter:   1412
  hvm code:          JumpCond False 1418
  explanation:       pop value (True), compare to False, and jump to 1418 if the same
  source code:       if (len(g->team1) == 0) and (len(g->team2) == 0):
                     ^^
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 359:
  program counter:   1413
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=40 column=9
  end statement:     line=40 column=31
  source code:       notify(?g->active_game)
                             ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame]

Step 360:
  program counter:   1414
  hvm code:          Push "active_game"
  explanation:       push constant "active_game"
  source code:       notify(?g->active_game)
                                ^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame, "active_game"]

Step 361:
  program counter:   1415
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("active_game", ?thegame); push result (?thegame["active_game"])
  source code:       notify(?g->active_game)
                             ^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["active_game"]]

Step 362:
  program counter:   1416
  hvm code:          Apply PC(1067)
  explanation:       pop an argument (?thegame["active_game"]) and call method (1067: "notify")
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, ?thegame["active_game"]]

Step 363:
  program counter:   1067
  hvm code:          Frame notify(c)
  explanation:       pop argument (?thegame["active_game"]), assign to c, and run method "notify"
  module:            synch
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }]

Step 364:
  program counter:   1068
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=57 column=16
  end statement:     line=59 column=6
  source code:       atomically if !c != bag.empty():
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"])

Step 365:
  program counter:   1069
  hvm code:          LoadVar c
  explanation:       push value (?thegame["active_game"]) of variable "c"
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                    ^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, ?thegame["active_game"]]

Step 366:
  program counter:   1070
  hvm code:          Load
  explanation:       pop address (?thegame["active_game"]) and push value ({:})
  source code:       atomically if !c != bag.empty():
                                   ^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}]

Step 367:
  program counter:   1071
  hvm code:          Push PC(541)
  explanation:       push program counter constant 541 ()
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, PC(541)]

Step 368:
  program counter:   1072
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       atomically if !c != bag.empty():
                                                  ^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, PC(541), []]

Step 369:
  program counter:   1073
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(541)); push result (?PC(541)[[]])
  source code:       atomically if !c != bag.empty():
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, ?PC(541)[[]]]

Step 370:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (541: "empty")
  start expression:  line=57 column=25
  end expression:    line=57 column=35
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"]) --> empty()
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, [], 17186, []]

Step 371:
  program counter:   541
  hvm code:          Frame empty()
  explanation:       pop argument () and run method "empty"
  module:            bag
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 372:
  program counter:   542
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=2 column=5
  end statement:     line=2 column=12
  source code:       bg = {:}
                          ^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, [], 17186, { "c": ?thegame["active_game"] }, {:}]

Step 373:
  program counter:   543
  hvm code:          StoreVar bg
  explanation:       pop value ({:}) and store locally in variable \"bg\"
  source code:       bg = {:}
                     ^^^^
  method variables:  { bg: {:} }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, [], 17186, { "c": ?thegame["active_game"] }]

Step 374:
  program counter:   544
  hvm code:          ReturnOp(bg)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=1 column=23
  source code:       def empty() returns bg:
                     ^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["active_game"] }
  call trace:        player(5) --> game_join(?thegame, 5) --> notify(?thegame["active_game"])
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, {:}, {:}]

Step 375:
  program counter:   1075
  hvm code:          2-ary !=
  explanation:       pop 2 values ({:}, {:}); check if the values are unequal; push result (False)
  module:            synch
  start statement:   line=57 column=16
  end statement:     line=57 column=36
  source code:       atomically if !c != bag.empty():
                                   ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }, False]

Step 376:
  program counter:   1076
  hvm code:          JumpCond False 1093
  explanation:       pop value (False), compare to False, and jump to 1093 if the same
  source code:       atomically if !c != bag.empty():
                                ^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 22658, { "g": ?thegame, "id": 5 }]

Step 377:
  program counter:   1093
  hvm code:          DelVar c
  explanation:       delete method variable c
  source code:       atomically if !c != bag.empty():
                                ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 378:
  program counter:   1094
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=57 column=16
  end expression:    line=57 column=36

Step 379:
  program counter:   1095
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=56 column=1
  end statement:     line=56 column=14
  source code:       def notify(c):
                     ^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, id: 5 }
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }, None]

Step 380:
  program counter:   1417
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=40 column=9
  end statement:     line=40 column=31
  source code:       notify(?g->active_game)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 381:
  program counter:   1418
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=44 column=5
  end statement:     line=44 column=118
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                ^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame]

Step 382:
  program counter:   1419
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                   ^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame, "team1"]

Step 383:
  program counter:   1420
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                ^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, ?thegame["team1"]]

Step 384:
  program counter:   1421
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=44 column=16
  end expression:    line=44 column=23
  call trace:        player(5) --> game_join(?thegame, 5)
  stack:             [{:}, [], 25378, { "self": 5 }, {}]

Step 385:
  program counter:   1422
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, 0]

Step 386:
  program counter:   1423
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                                             ^
  stack:             [{:}, [], 25378, { "self": 5 }, 0, 0]

Step 387:
  program counter:   1424
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                            ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, True]

Step 388:
  program counter:   1425
  hvm code:          JumpCond True 1456
  explanation:       pop value (True), compare to True, and jump to 1456 if the same
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 389:
  program counter:   1456
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=44 column=11
  end expression:    line=44 column=117
  stack:             [{:}, [], 25378, { "self": 5 }, True]

Step 390:
  program counter:   1457
  hvm code:          JumpCond False 1470
  explanation:       pop value (True), compare to False, and jump to 1470 if the same
  source code:       while (len(g->team1) == 0) or (len(g->team1) != len(g->team2)) or ((id not in g->team1) and (id not in g->team2)):
                     ^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }]

Step 391:
  program counter:   1458
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=45 column=9
  end statement:     line=45 column=35
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, []]

Step 392:
  program counter:   1459
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                           ^
  stack:             [{:}, [], 25378, { "self": 5 }, [], ?thegame]

Step 393:
  program counter:   1460
  hvm code:          Push "players"
  explanation:       push constant "players"
  source code:       wait(?g->players, ?g->lock)
                              ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], ?thegame, "players"]

Step 394:
  program counter:   1461
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("players", ?thegame); push result (?thegame["players"])
  source code:       wait(?g->players, ?g->lock)
                           ^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], ?thegame["players"]]

Step 395:
  program counter:   1462
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["players"], []); insert first value into the second; push result ([?thegame["players"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [ ?thegame["players"] ]]

Step 396:
  program counter:   1463
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       wait(?g->players, ?g->lock)
                                        ^
  stack:             [{:}, [], 25378, { "self": 5 }, [ ?thegame["players"] ], ?thegame]

Step 397:
  program counter:   1464
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       wait(?g->players, ?g->lock)
                                           ^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [ ?thegame["players"] ], ?thegame, "lock"]

Step 398:
  program counter:   1465
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       wait(?g->players, ?g->lock)
                                        ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [ ?thegame["players"] ], ?thegame["lock"]]

Step 399:
  program counter:   1466
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?thegame["lock"], [?thegame["players"]]); insert first value into the second; push result ([?thegame["players"], ?thegame["lock"]])
  source code:       wait(?g->players, ?g->lock)
                          ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [ ?thegame["players"], ?thegame["lock"] ]]

Step 400:
  program counter:   1467
  hvm code:          Apply PC(998)
  explanation:       pop an argument ([?thegame["players"], ?thegame["lock"]]) and call method (998: "wait")
  source code:       wait(?g->players, ?g->lock)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, [ ?thegame["players"], ?thegame["lock"] ]]

Step 401:
  program counter:   998
  hvm code:          Frame wait(c, lk)
  explanation:       pop argument ([?thegame["players"], ?thegame["lock"]]), assign to (c, lk), and run method "wait"
  module:            synch
  start statement:   line=46 column=1
  end statement:     line=46 column=16
  source code:       def wait(c, lk):
                     ^^^^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }]

Step 402:
  program counter:   999
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=47 column=5
  end statement:     line=47 column=15
  source code:       var cnt = 0
                               ^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, 0]

Step 403:
  program counter:   1000
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  source code:       var cnt = 0
                     ^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }]

Step 404:
  program counter:   1001
  hvm code:          DelVar cnt
  explanation:       delete method variable cnt
  start statement:   line=48 column=5
  end statement:     line=48 column=24
  source code:       let (), ctx = save():
                                       ^^
  method variables:  { c: ?thegame["players"], lk: ?thegame["lock"] }

Step 405:
  program counter:   1002
  hvm code:          Push ()
  explanation:       push constant ()
  start expression:  line=48 column=23
  end expression:    line=48 column=24
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, []]

Step 406:
  program counter:   1003
  hvm code:          Save
  explanation:       pop a value and save context
  source code:       let (), ctx = save():
                                   ^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, [ [], CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 407:
  program counter:   1004
  hvm code:          Continue
  explanation:       a no-op, must follow a Stop or Save operation
  start expression:  line=48 column=19
  end expression:    line=48 column=24

Step 408:
  program counter:   1005
  hvm code:          StoreVar ((), ctx)
  explanation:       pop value ([[], CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])]) and store locally in variable \"((), ctx)\"
  source code:       let (), ctx = save():
                     ^^^^^^^^^^^^^
  method variables:  { c: ?thegame["players"], ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }]

Step 409:
  program counter:   1006
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])

Step 410:
  program counter:   1007
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605)]

Step 411:
  program counter:   1008
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605), []]

Step 412:
  program counter:   1009
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                             ^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605), [], ?thegame["players"]]

Step 413:
  program counter:   1010
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 })
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 414:
  program counter:   1011
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 415:
  program counter:   1012
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])) of variable "ctx"
  source code:       cnt = bag.multiplicity(!c, ctx)
                                                ^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 416:
  program counter:   1013
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])])
  source code:       cnt = bag.multiplicity(!c, ctx)
                                            ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, PC(605), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 417:
  program counter:   1014
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])], PC(605)); push result (?PC(605)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])]])
  source code:       cnt = bag.multiplicity(!c, ctx)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?PC(605)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 418:
  program counter:   1015
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])]) and call method (605: "multiplicity")
  start expression:  line=50 column=19
  end expression:    line=50 column=43
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"]) --> multiplicity({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }]))
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, [], 16242, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 419:
  program counter:   605
  hvm code:          Frame multiplicity(bg, elt)
  explanation:       start of method multiplicity
  module:            bag
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, 0]

Step 420:
  program counter:   1016
  hvm code:          StoreVar cnt
  explanation:       pop value (0) and store locally in variable \"cnt\"
  module:            synch
  start statement:   line=50 column=13
  end statement:     line=50 column=43
  source code:       cnt = bag.multiplicity(!c, ctx)
                     ^^^^^
  method variables:  { c: ?thegame["players"], cnt: 0, ctx: CONTEXT({'type': 'pc', 'value': '1004'}), lk: ?thegame["lock"] }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }]

Step 421:
  program counter:   1017
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                      ^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"]]

Step 422:
  program counter:   1018
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696)]

Step 423:
  program counter:   1019
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), []]

Step 424:
  program counter:   1020
  hvm code:          LoadVar c
  explanation:       push value (?thegame["players"]) of variable "c"
  source code:       !c = bag.add(!c, ctx)
                                   ^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [], ?thegame["players"]]

Step 425:
  program counter:   1021
  hvm code:          Load
  explanation:       pop address (?thegame["players"]) and push value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 })
  source code:       !c = bag.add(!c, ctx)
                                  ^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [], { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 426:
  program counter:   1022
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, []); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ]]

Step 427:
  program counter:   1023
  hvm code:          LoadVar ctx
  explanation:       push value (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])) of variable "ctx"
  source code:       !c = bag.add(!c, ctx)
                                      ^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 } ], CONTEXT({'type': 'pc', 'value': '1004'})]

Step 428:
  program counter:   1024
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }]), [{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }]); insert first value into the second; push result ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])])
  source code:       !c = bag.add(!c, ctx)
                                  ^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], PC(696), [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 429:
  program counter:   1025
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])], PC(696)); push result (?PC(696)[[{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])]])
  source code:       !c = bag.add(!c, ctx)
                          ^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], ?PC(696)[[ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]]

Step 430:
  program counter:   1026
  hvm code:          Load
  explanation:       pop an argument ([{ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }])]) and call method (696: "add")
  start expression:  line=51 column=18
  end expression:    line=51 column=33
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"]) --> add({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }]))
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], [], 16418, [ { CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, CONTEXT({'type': 'pc', 'value': '1004'}) ]]

Step 431:
  program counter:   696
  hvm code:          Frame add(bg, elt)
  explanation:       start of method add
  module:            bag
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["players"], { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }]

Step 432:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value ({ CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 5 },[],23474,{ "g": ?thegame, "id": 5 }]): 1, CONTEXT(pc=1004,vars={ "c": ?thegame["players"], "lk": ?thegame["lock"] },readonly=0,atomic=0,aflag=0,il=0,stopped=1,terminated=0,eternal=0,sp=7,STACK[{:},[],25378,{ "self": 1 },[],23474,{ "g": ?thegame, "id": 1 }]): 1 }) and address (?thegame["players"]) and store
  module:            synch
  start statement:   line=51 column=13
  end statement:     line=51 column=33
  source code:       !c = bag.add(!c, ctx)
                     ^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1, 5 ] } }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }]

Step 433:
  program counter:   1028
  hvm code:          LoadVar lk
  explanation:       push value (?thegame["lock"]) of variable "lk"
  start statement:   line=52 column=13
  end statement:     line=52 column=23
  source code:       !lk = False
                      ^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["lock"]]

Step 434:
  program counter:   1029
  hvm code:          Push False
  explanation:       push constant False
  source code:       !lk = False
                           ^^^^^
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }, ?thegame["lock"], False]

Step 435:
  program counter:   1030
  hvm code:          Store
  explanation:       pop value (False) and address (?thegame["lock"]) and store
  source code:       !lk = False
                     ^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1, 5 ] } }
  stack:             [{:}, [], 25378, { "self": 5 }, [], 23474, { "g": ?thegame, "id": 5 }]

Step 436:
  program counter:   1031
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=49 column=9
  end statement:     line=49 column=19
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Running thread T1: game_umpire(?thegame)
mode:  runnable
stack: ['?thegame']
other threads:
  T0: pc=1628 terminated atomic __init__()
  T2: pc=1032 blocked player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1580 runnable player(2)
    about to run method player with argument 2
  T4: pc=1580 runnable player(3)
    about to run method player with argument 3
  T5: pc=1580 runnable player(4)
    about to run method player with argument 4
  T6: pc=1032 blocked player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1580 runnable player(6)
    about to run method player with argument 6
shared variables:
  thegame: { "active_game": {:}, "lock": False, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1, 5 ] }
state id: 12484
================================================

Step 437:
  program counter:   1233
  hvm code:          Frame game_umpire(g)
  explanation:       pop argument (?thegame), assign to g, and run method "game_umpire"
  module:            game
  start statement:   line=8 column=1
  end statement:     line=8 column=19
  source code:       def game_umpire(g):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        game_umpire(?thegame)
  stack:             [{:}]

Step 438:
  program counter:   1234
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=9 column=5
  end statement:     line=9 column=21
  source code:       acquire(?g->lock)
                              ^
  stack:             [{:}, ?thegame]

Step 439:
  program counter:   1235
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?g->lock)
                                 ^^^^
  stack:             [{:}, ?thegame, "lock"]

Step 440:
  program counter:   1236
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?thegame); push result (?thegame["lock"])
  source code:       acquire(?g->lock)
                              ^^^^^^^
  stack:             [{:}, ?thegame["lock"]]

Step 441:
  program counter:   1237
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?thegame["lock"]) and call method (954: "acquire")
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        game_umpire(?thegame) --> acquire(?thegame["lock"])
  stack:             [{:}, [], 19794, ?thegame["lock"]]

Step 442:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?thegame["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?thegame["lock"] }
  stack:             [{:}, [], 19794, { "g": ?thegame }]

Step 443:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        game_umpire(?thegame) --> acquire(?thegame["lock"])

Step 444:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 445:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 19794, { "g": ?thegame }, ?thegame["lock"]]

Step 446:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?thegame["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 19794, { "g": ?thegame }, False]

Step 447:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 19794, { "g": ?thegame }, True]

Step 448:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 19794, { "g": ?thegame }]

Step 449:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 450:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 451:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?thegame["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 19794, { "g": ?thegame }, ?thegame["lock"]]

Step 452:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 453:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 19794, { "g": ?thegame }, ?thegame["lock"], True]

Step 454:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?thegame["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1, 5 ] } }
  stack:             [{:}, [], 19794, { "g": ?thegame }]

Step 455:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 456:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame }
  call trace:        game_umpire(?thegame)
  stack:             [{:}, None]

Step 457:
  program counter:   1238
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            game
  start statement:   line=9 column=5
  end statement:     line=9 column=21
  source code:       acquire(?g->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 458:
  program counter:   1239
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=10 column=5
  end statement:     line=10 column=15
  source code:       while True:
                           ^^^^
  stack:             [{:}, True]

Step 459:
  program counter:   1240
  hvm code:          JumpCond False 1369
  explanation:       pop value (True), compare to False, and jump to 1369 if the same
  source code:       while True:
                     ^^^^^
  stack:             [{:}]

Step 460:
  program counter:   1241
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=13 column=9
  end statement:     line=13 column=84
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                ^
  stack:             [{:}, ?thegame]

Step 461:
  program counter:   1242
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                   ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 462:
  program counter:   1243
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 463:
  program counter:   1244
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([1, 5])
  start expression:  line=13 column=20
  end expression:    line=13 column=29
  call trace:        game_umpire(?thegame)
  stack:             [{:}, [ 1, 5 ]]

Step 464:
  program counter:   1245
  hvm code:          1-ary len
  explanation:       pop a value ([1, 5]); compute the length of the list; push result (2)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                            ^^^^^^^^^^^^^^^
  stack:             [{:}, 2]

Step 465:
  program counter:   1246
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                              ^
  stack:             [{:}, 2, 2]

Step 466:
  program counter:   1247
  hvm code:          2-ary <
  explanation:       pop 2 values (2, 2); check if second value is less than the first; push result (False)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                            ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 467:
  program counter:   1248
  hvm code:          JumpCond True 1265
  explanation:       pop value (False), compare to True, and jump to 1265 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 468:
  program counter:   1249
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                         ^
  stack:             [{:}, ?thegame]

Step 469:
  program counter:   1250
  hvm code:          Push "team1"
  explanation:       push constant "team1"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                            ^^^^^
  stack:             [{:}, ?thegame, "team1"]

Step 470:
  program counter:   1251
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team1", ?thegame); push result (?thegame["team1"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                         ^^^^^^^^
  stack:             [{:}, ?thegame["team1"]]

Step 471:
  program counter:   1252
  hvm code:          Load
  explanation:       pop address (?thegame["team1"]) and push value ({})
  start expression:  line=13 column=45
  end expression:    line=13 column=52
  call trace:        game_umpire(?thegame)
  stack:             [{:}, {}]

Step 472:
  program counter:   1253
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                     ^^^^^^^^^^^^^
  stack:             [{:}, 0]

Step 473:
  program counter:   1254
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                      ^
  stack:             [{:}, 0, 0]

Step 474:
  program counter:   1255
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 475:
  program counter:   1256
  hvm code:          JumpCond True 1265
  explanation:       pop value (False), compare to True, and jump to 1265 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 476:
  program counter:   1257
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                 ^
  stack:             [{:}, ?thegame]

Step 477:
  program counter:   1258
  hvm code:          Push "team2"
  explanation:       push constant "team2"
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                    ^^^^^
  stack:             [{:}, ?thegame, "team2"]

Step 478:
  program counter:   1259
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("team2", ?thegame); push result (?thegame["team2"])
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                 ^^^^^^^^
  stack:             [{:}, ?thegame["team2"]]

Step 479:
  program counter:   1260
  hvm code:          Load
  explanation:       pop address (?thegame["team2"]) and push value ({})
  start expression:  line=13 column=69
  end expression:    line=13 column=76
  call trace:        game_umpire(?thegame)
  stack:             [{:}, {}]

Step 480:
  program counter:   1261
  hvm code:          1-ary len
  explanation:       pop a value ({}); push result (0)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                             ^^^^^^^^^^^^^
  stack:             [{:}, 0]

Step 481:
  program counter:   1262
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                                              ^
  stack:             [{:}, 0, 0]

Step 482:
  program counter:   1263
  hvm code:          2-ary !=
  explanation:       pop 2 values (0, 0); check if the values are unequal; push result (False)
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                                             ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, False]

Step 483:
  program counter:   1264
  hvm code:          Jump 1266
  explanation:       set program counter to 1266
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                                                 ^^

Step 484:
  program counter:   1266
  hvm code:          JumpCond False 1279
  explanation:       pop value (False), compare to False, and jump to 1279 if the same
  source code:       while (len(g->waiting) < 2) or (len(g->team1) != 0) or (len(g->team2) != 0):
                     ^^^^^
  stack:             [{:}]

Step 485:
  program counter:   1279
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  start statement:   line=17 column=9
  end statement:     line=17 column=67
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                             ^
  stack:             [{:}, ?thegame]

Step 486:
  program counter:   1280
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                ^^^^^^^
  stack:             [{:}, ?thegame, "waiting"]

Step 487:
  program counter:   1281
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                             ^^^^^^^^^^
  stack:             [{:}, ?thegame["waiting"]]

Step 488:
  program counter:   1282
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([1, 5])
  start expression:  line=17 column=33
  end expression:    line=17 column=42
  call trace:        game_umpire(?thegame)
  stack:             [{:}, [ 1, 5 ]]

Step 489:
  program counter:   1283
  hvm code:          1-ary len
  explanation:       pop a value ([1, 5]); compute the length of the list; push result (2)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                         ^^^^^^^^^^^^^^^
  stack:             [{:}, 2]

Step 490:
  program counter:   1284
  hvm code:          LoadVar g
  explanation:       push value (?thegame) of variable "g"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                ^
  stack:             [{:}, 2, ?thegame]

Step 491:
  program counter:   1285
  hvm code:          Push "waiting"
  explanation:       push constant "waiting"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                   ^^^^^^^
  stack:             [{:}, 2, ?thegame, "waiting"]

Step 492:
  program counter:   1286
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("waiting", ?thegame); push result (?thegame["waiting"])
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                ^^^^^^^^^^
  stack:             [{:}, 2, ?thegame["waiting"]]

Step 493:
  program counter:   1287
  hvm code:          Load
  explanation:       pop address (?thegame["waiting"]) and push value ([1, 5])
  start expression:  line=17 column=52
  end expression:    line=17 column=61
  call trace:        game_umpire(?thegame)
  stack:             [{:}, 2, [ 1, 5 ]]

Step 494:
  program counter:   1288
  hvm code:          1-ary len
  explanation:       pop a value ([1, 5]); compute the length of the list; push result (2)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                            ^^^^^^^^^^^^^^^
  stack:             [{:}, 2, 2]

Step 495:
  program counter:   1289
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                                              ^
  stack:             [{:}, 2, 2, 2]

Step 496:
  program counter:   1290
  hvm code:          2-ary %
  explanation:       pop 2 values (2, 2); second value modulo the first; push result (0)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                                            ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 2, 0]

Step 497:
  program counter:   1291
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 2); the second integer minus the first; push result (2)
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 2]

Step 498:
  program counter:   1292
  hvm code:          StoreVar pairedplayers
  explanation:       pop value (2) and store locally in variable \"pairedplayers\"
  source code:       let pairedplayers = len(g->waiting) - (len(g->waiting) % 2):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { g: ?thegame, pairedplayers: 2 }
  stack:             [{:}]

Step 499:
  program counter:   1293
  hvm code:          Push ?game$range
  explanation:       push constant ?game$range
  start statement:   line=18 column=13
  end statement:     line=18 column=44
  source code:       for i in range(pairedplayers//2):
                              ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?game$range]

Step 500:
  program counter:   1294
  hvm code:          LoadVar pairedplayers
  explanation:       push value (2) of variable "pairedplayers"
  source code:       for i in range(pairedplayers//2):
                                    ^^^^^^^^^^^^^
  stack:             [{:}, ?game$range, 2]

Step 501:
  program counter:   1295
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       for i in range(pairedplayers//2):
                                                   ^
  stack:             [{:}, ?game$range, 2, 2]

Step 502:
  program counter:   1296
  hvm code:          2-ary //
  explanation:       pop 2 values (2, 2); integer divide; push result (1)
  source code:       for i in range(pairedplayers//2):
                                    ^^^^^^^^^^^^^^^^
  stack:             [{:}, ?game$range, 1]

Step 503:
  program counter:   1297
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?game$range); push result (?game$range[1])
  source code:       for i in range(pairedplayers//2):
                              ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?game$range[1]]

Step 504:
  program counter:   1298
  hvm code:          Load
  explanation:       pop an address and push the value at the address
  start expression:  line=18 column=22
  end expression:    line=18 column=44
  call trace:        game_umpire(?thegame)
  new mode:          failed
  stack:             [{:}]
  operation failed:  Load ?game$range[1]: can't load

================================================
Final state
================================================
Threads:
  T0: pc=1628 terminated atomic __init__()
  T1: pc=1298 failed game_umpire(?thegame)
  T2: pc=1032 runnable player(1) --> game_join(?thegame, 1) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T3: pc=1580 runnable player(2)
    about to run method player with argument 2
  T4: pc=1580 runnable player(3)
    about to run method player with argument 3
  T5: pc=1580 runnable player(4)
    about to run method player with argument 4
  T6: pc=1032 runnable player(5) --> game_join(?thegame, 5) --> wait(?thegame["players"], ?thegame["lock"])
    about to execute synch:53:         atomically when (not !lk) and (bag.multiplicity(!c, ctx) <= cnt):
  T7: pc=1580 runnable player(6)
    about to run method player with argument 6
Variables:
  thegame: { "active_game": {:}, "lock": True, "players": { CONTEXT({'type': 'pc', 'value': '1004'}): 1, CONTEXT({'type': 'pc', 'value': '1004'}): 1 }, "team1": {}, "team2": {}, "waiting": [ 1, 5 ] }
